<html><head lang="ja"><link rel="icon" type="image/png" href="favicon.png"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/><meta property="og:type" content="article"/><meta property="og:image" content="https://hinaser.github.io/Machine-Learning/preview.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://hinaser.github.io/Machine-Learning/preview.png"/><meta name="twitter:image:width" content="1200"/><meta name="twitter:image:height" content="630"/><meta name="author" content="Hinase"/><meta name="keywords" content="TensorFlow, Machine Learning, Math, Mathematics"/><meta property="og:title" content="機械学習のための数学"/><meta property="og:description" content="機械学習を理解するために必要な数学を解説します。"/><meta property="og:url" content="https://hinaser.github.io/Machine-Learning/math-for-ml.html"/><meta name="twitter:title" content="機械学習のための数学"/><meta name="twitter:description" content="機械学習を理解するために必要な数学を解説します。"/><meta name="twitter:url" content="https://hinaser.github.io/Machine-Learning/math-for-ml.html"/><title>機械学習のための数学</title><link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"/><link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css"/><script defer="" src="https://code.getmdl.io/1.3.0/material.min.js"></script><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/><link href="https://fonts.googleapis.com/earlyaccess/notosansjapanese.css" rel="stylesheet"/><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="css/lib.css" type="text/css" data-turbolinks-track="reload"/><link rel="stylesheet" href="css/main.css?e6345cfcaf" type="text/css" data-turbolinks-track="reload"/><script id="st_insights_js" type="text/javascript" src="https://ws.sharethis.com/button/buttons.js?publisher=8fde68e6-f234-4808-b7ab-c498ac41fe48"></script><script type="text/javascript">stLight.options({
    publisher: "8fde68e6-f234-4808-b7ab-c498ac41fe48",
    doNotHash: true,
    doNotCopy: true,
    hashAddressBar: false
});</script><script src="js/lib.js?09ad6da019" data-turbolinks-track="reload"></script></head><body><div class="dpln-layout top-header-left-nav-layout fixed-top"><header class="dpln-layout-header"><i class="material-icons" id="toggle-nav">view_headline</i><span class="site-title">機械学習、ディープラーニング</span></header><nav class="dpln-layout-nav"><figure class="collapsible" data-page="learntensorflowplayground"><figcaption><span class="menu-title">TensorFlow Playgroundの仕組み</span><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">keyboard_arrow_down</i></button></figcaption><ul><li><a href="index.html#preface-part">はじめに</a></li><li><a href="index.html#reference-part">参考文献</a></li><li><a href="index.html#summary-part">Playgroundの仕組み</a></li><li><a href="index.html#learningsettings-part">ニューラルネットワークについて</a></li><li><a href="index.html#about-learning-in-nn-part">ニューラルネットワークの学習に関する設定</a></li><li><a href="index.html#learningrate-part">学習率</a></li><li><a href="index.html#activator-part">活性化関数</a></li><li><a href="index.html#regularization-part">正則化、正則化項</a></li><li><a href="index.html#problemtype-part">統計モデルの種類</a></li><li><a href="index.html#inputdata-part">データに関する設定</a></li><li><a href="index.html#dataselection-part">どのデータセットを使うか</a></li><li><a href="index.html#ratio-of-training-data-part">トレーニングデータの割合</a></li><li><a href="index.html#noise-part">ノイズ</a></li><li><a href="index.html#batchsize-part">バッチサイズ</a></li><li><a href="index.html#feature-part">入力するデータの特徴と隠し層</a></li><li><a href="index.html#backpropagation-part">バックプロパゲーション(誤差逆伝搬法)</a></li></ul></figure><figure class="collapsible" data-page="deeplearning-by-tensorflow"><figcaption><span class="menu-title">TensorFlowでディープラーニング</span><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">keyboard_arrow_down</i></button></figcaption><ul><li><a href="deeplearning-by-tensorflow.html">TensorFlowのインストール</a></li><li><a href="deeplearning-by-tensorflow-with-gpu.html">TensorFlowのインストール(GPU利用編)</a></li></ul></figure><figure class="collapsible" data-page="math-for-ml"><figcaption><span class="menu-title">機械学習のための数学</span><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">keyboard_arrow_down</i></button></figcaption><div class="dpln-expand"></div><ul><li><a href="math-for-ml.html">はじめに</a></li><li><a href="math-for-ml.html#random-variable">確率変数</a></li><li><a href="math-for-ml.html#probability-distribution">確率分布</a></li><li><a href="math-for-ml.html#pmf">離散確率分布</a></li><li><a href="math-for-ml.html#pdf">連続確率分布</a></li><li><a href="math-for-ml.html#expectation">期待値</a></li><li><a href="math-for-ml.html#self-information">自己情報量</a></li><li><a href="math-for-ml.html#entropy">エントロピー</a></li><li><a href="math-for-ml.html#kl-divergence">KL情報量</a></li><li><a href="math-for-ml.html#cross-entropy">クロスエントロピー</a></li><li><a href="math-for-ml.html#logits">ロジット</a></li><li><a href="math-for-ml.html#softmax">ソフトマックス関数</a></li><li><a href="math-for-ml.html#sigmoid">シグモイド関数</a></li><li><a href="math-for-ml.html#multiclass-classification">多クラス分類</a></li><li><a href="math-for-ml.html#multilabel-classification">マルチラベル分類</a></li></ul></figure><figure class="collapsible" data-page="[&quot;profile&quot;, &quot;reference&quot;, &quot;useful-tools-and-services&quot;, &quot;private-thoughts&quot;]"><figcaption><span class="menu-title">その他</span><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">keyboard_arrow_down</i></button></figcaption><ul><li><a href="profile.html">著者プロフィール</a></li><li><a href="reference.html">参考サイト集</a></li><li><a href="useful-tools-and-services.html">お世話になっているツール/サービス</a></li><li><a href="private-thoughts.html">独り言</a></li></ul></figure></nav><main class="dpln-layout-main"><article class="main-article" data-page="math-for-ml"><a class="in-page-anchor" id="preface"></a><h1>機械学習のための数学</h1><div class="paragraph"><p>機械学習のより深い理解に必要な数学の基礎についてまとめます。<br/><small>2017/3/11現在加筆中です。内容は適宜追補します。</small></p><p>このページで取り扱う記号の記法については<a href="http://www.deeplearningbook.org/contents/notation.html" target="_blank">Goodfellow et al.(2016)</a>を踏襲します。</p></div><div class="paragraph"><a class="in-page-anchor" id="random-variable"></a><h4>Random variables - 確率変数</h4><h6>特徴</h6><ul class="features"><li>確率変数と書くと大仰で難解な概念に思えるが、英語名のRandom variablesで覚えると理解しやすい。ただの取りうる値がランダムな変数。</li><li>厳密に言うと確率変数$X$は標本空間$\Omega$から可測空間$E$への可測関数。</li><li>身近な例ではコイン投げにおいて、標本空間$\Omega$は'表'と'裏'の2つの元を持つ集合ととれる。
'表'と'裏'のラベルのままだと数学的に扱いにくいので、通常は'表'=1, '裏'=0と標本空間の元に数を割り当てる。
この時標本空間に対応づけられている$\{0,1\}$が確率変数$X$の取りうる値の集合となる。</li><li>確率変数は離散値をとる場合と連続的な値をとる場合の2種類ある。</li><li>確率変数が離散的であるとは$X$の個数が有限または可算無限であることをいう。</li><li>確率変数が連続的であるとは$X$の個数が非可算であることをいう。</li></ul><h6>厳密な理解に必要な知識</h6><ul class="prerequisite"><li><a href="https://en.wikipedia.org/wiki/Measure_(mathematics)" target="_blank">Measure Theory - 測度論</a></li><li><a href="https://www.encyclopediaofmath.org/index.php/Measurable_space" target="_blank">Measuable Space - 可測空間</a></li><li><a href="https://en.wikipedia.org/wiki/Measurable_function" target="_blank">Measure Function - 可測関数</a></li><li><a href="https://en.wikipedia.org/wiki/Probability_space" target="_blank">Probability Space - 確率空間</a></li></ul></div><div class="paragraph"><a class="in-page-anchor" id="probability-distribution"></a><h4>Probabiity distribution function - 確率分布関数</h4><h6>特徴</h6><ul class="features"><li>確率変数$X$の起こりやすさを表した関数。確率変数が離散的であるか連続的であるかによって確率分布関数の性質は異なる。
前者の場合の確率分布関数をPMF(Probability Mass Function, 確率質量関数)と呼び、後者をPDF(Probability Density Function、 確率密度関数)と呼ぶ。</li><li>PMFを考えるとき、一般に確率分布関数は大文字の$P$で表記される。</li><li>PDFを考えるとき、一般に確率分布関数は小文字の$p$で表記される。</li><li>$X$が確率分布関数$P$にしたがって分布するとき、
$$ X \sim P$$
と書く。</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="pmf"></a><h4>Discrete Probabiity distribution function - 離散確率分布関数</h4><h6>特徴</h6><ul class="features"><li>$$ 0 \le P(X=x) \le 1 $$</li><li>$$ \sum_{x} P(x) = 1 $$</li><li>$P(X=x)$は事象$x$の起こりえる確率をそのまま表す。</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="pdf"></a><h4>Continuous Probabiity distribution function - 連続確率分布関数</h4><h6>特徴</h6><ul class="features"><li>$$ 0 \le p(x \in dx) $$</li><li>$$ \int_{x} p(x) dx = 1 $$</li><li>$p(x)$は離散確率分布と異なり事象$x$の起こりえる確率を直接表さない。
非可算無限個の元を持つ確率変数$X$に対して無限分の1である$X=x$をピンポイントで
拾い上げる確率は限りなくゼロに近いため。
通常は$X$上の連続区間$I \in [a,b]$を考え、区間$I$で表せられる事象が発生する確率を
$$ \int_{a}^{b} p(x) dx $$で表す。</li><li>連続確率分布の例として一様分布(Uniform Distribution)がある。これは確率分布関数が任意の閉区間$I \in [a,b]$において、
$$ p(x) = u(x;a,b) = \frac{1}{b-a}$$
で表される確率密度関数である。
区間の長さのみによって確率が決まる非常にシンプルな分布関数である。</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="expectation"></a><h4>Expectation - 期待値</h4><h6>特徴</h6><ul class="features"><li>離散確率分布の場合:
$$ \mathbb{E}[f(x)] = \sum_{x} P(x) f(x) $$</li><li>連続確率分布の場合:
$$ \mathbb{E}[f(x)] = \int_{x} p(x) f(x) dx $$</li><li>線形性:
$$ \mathbb{E}[\alpha f(x) + \beta g(x)] = \alpha \mathbb{E}[f(x)] + \beta \mathbb{E}[g(X)] $$</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="self-information"></a><h4>Self Information - 自己情報量</h4><h6>特徴</h6><ul class="features"><li>surprisalとも言う。情報の量を定義するために用いられる概念。</li><li>$P(x)=1$、つまりわかりきっている情報は情報量ゼロとなる。</li><li>まれな情報ほど自己情報量$I(x)$が大きい。</li><li>定義:
$$I(x) = - \log P(x)$$</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="entropy"></a><h4>Entropy - エントロピー</h4><h6>特徴</h6><ul class="features"><li>平均情報量とも言う。</li><li>自己情報量ではある単一の事象$x$における情報量しかわからなかったが、エントロピーの概念を用いれば、
標本空間全体の情報量を定量することができる。</li><li>定義:
$$ H(X) = E_{X \sim P}[I(X)] = - \sum_{X \sim P} P(X) \ln{P(X)}$$</li><li>$X \sim P$とすると、エントロピーは$$H(P)$$とも表記される。</li><li>起こりうる事象の数を固定すると、分布関数の選び方によってエントロピーの大小が変わる。
a個の事象を考えるとき、それぞれの事象の確率が等しく$1/a$である一様分布はこの事象のエントロピーを最大にする分布である。
これは事象の不確定さが最大ということを意味する。
不確定さが小さくなるほどエントロピーも小さくなる。</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="kl-divergence"></a><h4>Kullback-Leibler divergence - カルバック・ライブラー情報量</h4><h6>特徴</h6><ul class="features"><li>2つの確率分布が互いにどれだけ異なっているかを表す指標。$D_{\text{KL}}$で表記される。</li><li>$$ D_{\text{KL}}(P||Q) = E_{x \sim P}[\log \frac{P(x)}{Q(x)}] = \sum_{x} P(x) \log \frac{P(x)}{Q(x)}$$</li><li><a href="https://ja.wikipedia.org/wiki/%E3%82%AE%E3%83%96%E3%82%B9%E3%81%AE%E4%B8%8D%E7%AD%89%E5%BC%8F" target="_blank">ギブスの不等式</a>より、$D_{\text{KL}}(P||Q) \ge 0$ 。$D_{\text{KL}}(P||Q)=0$となるのは全ての$x$において$P(x)=Q(x)$となる場合のみ。<br/>つまり確率分布が互いに全く同一であるときにカルバック・ライブラー情報量は$0$になる。</li><li>$$D_{\text{KL}}(P||Q) \ne D_{\text{KL}}(Q||P)$$</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="cross-entropy"></a><h4>Cross Entropy - クロスエントロピー</h4><h6>特徴</h6><ul class="features"><li>確率分布$P,Q$のクロスエントロピー$H(P,Q)$はエントロピー$H(P)$およびKL Divergenceを使うと下記の式で表せられる。
$$ H(P,Q) = H(P) + D_{\text{KL}}(P||Q) $$</li><li>上記を展開すると
$$
\begin{align}
  H(P,Q) &= -\sum_{x \sim P} P(x) \log P(x) + \sum_{x} P(x) \log \frac{P(x)}{Q(x)} \\
         &= -\sum_{x \sim P} P(x) \log Q(x)
\end{align}
$$</li><li>Quadratic Cost Functionの場合、誤差の最小値は0となるがクロスエントロピーを誤差関数とする場合はその値の最小値はゼロとはならない。
とはいえクロスエントロピーを最小にすることとKL Divergenceを最小にすることは同義でありこの場合は最小値はゼロとなる。
そのためクロスエントロピーを最小化する、
といったときには誤差の測定に$H(P,Q)$と$D_{\text{KL}}$のどちらを使おうとしているのか注意が必要。</li><li>機械学習では入力がk個のクラスのうちどれに該当するか判定する場合に誤差関数として採用されることが多い。<br/>2値分類(Binary Classification)を例として考える。入力が1であると考えられる確率を$\hat y_1$、2の場合は確率を$\hat y_2$とおく。
また、入力に対する真の判定結果をそれぞれ$y_1, y_2$とおく。このとき
$$
\begin{align}
H(P,Q) = - \sum_{i}^{2} y_i \log \hat{y_i} &= - (y_1 \log \hat{y_1} + y_2 \log \hat{y_2} ) \\
&= - (y_1 \log \hat{y_1} + (1-y_1) \log (1-\hat{y_1}) )
\end{align}
$$
となる。2値分類のため
$ y_2 = 1 - y1,\, \hat y_2 = 1 - \hat y_1$であることを利用している。</li><li>MNISTのように10個の出力ニューロンが出力層に並べられている場合でも、出力層の1つ1つのニューロンはそれぞれ2値分類をしている。
例えば出力層の最初のニューロンは入力が0かそうでないかを判断するニューロンであり、出力層の最後のニューロンは入力が9かそうでないかを
判定するだけである。そのため上記の2値分類用のクロスエントロピーを用いて出力層のニューロンの誤差を定量できる。</li></ul><p>2つの離散確率分布$P(x),\,Q(x)$に対するエントロピー、クロスエントロピー、KL情報量の変化の様子を体感できるデモを用意した。<br/>機械学習では$P(x)$を参照用の真の確率分布、$Q(x)$をニューロンの出力した確率分布とすると、$Q(x)$の形状を$P(x)$に近づけていく
操作が繰り返される。$Q$の形が$P$に近いほどKL情報量が$0$に近づく様子が確認できる。</p><div class="entropy-demo"><div class="probability-bar" id="prob-P"><div class="each-prob p1">$P_1$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="p1-p2"></div><div class="each-prob p2">$P_2$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="p2-p3"></div><div class="each-prob p3">$P_3$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="p3-p4"></div><div class="each-prob p4">$P_4$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="p4-p5"></div><div class="each-prob p5">$P_5$<div class="prob-val"><span>0.200</span></div></div><div class="entropy-val">$H(P)$&nbsp;=&nbsp;<span>$-\ln(0.2)$</span></div></div><div class="line-between-entropy"><svg xmlns="http://www.w3.org/2000/svg"><line data-link="p1-p2_q1-q2" stroke-width="1" stroke="rgba(0,200,128,.8)"></line><line data-link="p2-p3_q2-q3" stroke-width="1" stroke="rgba(0,200,128,.8)"></line><line data-link="p3-p4_q3-q4" stroke-width="1" stroke="rgba(0,200,128,.8)"></line><line data-link="p4-p5_q4-q5" stroke-width="1" stroke="rgba(0,200,128,.8)"></line></svg><div class="cross-entropy-val">$H(P,Q)$&nbsp;=&nbsp;<span class="cross-entropy">$-\ln(0.2)$</span><br/>$D_{KL}(P||Q)$&nbsp;=&nbsp;<span class="kl-divergence">0</span></div></div><div class="probability-bar" id="prob-Q"><div class="each-prob q1">$Q_1$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="q1-q2"></div><div class="each-prob q2">$Q_2$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="q2-q3"></div><div class="each-prob q3">$Q_3$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="q3-q4"></div><div class="each-prob q4">$Q_4$<div class="prob-val"><span>0.200</span></div></div><div class="prob-separator" data-separator="q4-q5"></div><div class="each-prob q5">$Q_5$<div class="prob-val"><span>0.200</span></div></div><div class="entropy-val">$H(Q)$&nbsp;=&nbsp;<span>$-\ln(0.2)$</span></div></div></div></div><div class="paragraph"><a class="in-page-anchor" id="logits"></a><h4>Logits - ロジット</h4><h6>特徴</h6><ul class="features"><li>確率をpとすると、
$$logit(p) = \ln \frac{p}{1-p}$$</li><li>ロジットの逆関数はシグモイド関数$$\sigma(z)=1/(1+e^{-z})$$
つまり$$\sigma(logit(p)) = p$$</li><li>$p/(1-p)$はオッズ(odds)と呼ばれる。</li><li>ロジット$\ln \frac{p}{1-p}$の値域は$(-\infty,+\infty)$であり、$logits \in \mathbf R$。<br/>つまり実変数$x$をロジットと見立ててシグモイド関数にかけると確率が得られたと見ることができる。</li><li>TensorFlow等の機械学習フレームワークでは、これから確率に変換しようとしている出力層のニューロンの出力値を
よくロジットと呼ぶことが多い。</li><li>MNISTのチュートリアルではトレーニングデータとして用意されている出力の真の値は確率分布だが、
ニューロンの出力値は$\mathbf{w}^{\mathbf{T}} \mathbf{x} + \mathbf{b}$ であり、
その値は1より大きくなりえることから$p \in [0,1]$の確率の公理を満たさない。<br/>そのためこのようなケースでは出力層のニューロンについては出力値を確率を表すように変換してやらなければならない。
ニューロンの出力をソフトマックス関数やシグモイド関数に通してからクロスエントロピーの計算をし、誤差を最小化させるという流れが一般的。</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="softmax"></a><h4>Softmax function - ソフトマックス関数</h4><h6>特徴</h6><ul class="features"><li>$$\sigma(\mathbf{z})_j = \frac{e^{z_j}}{\sum_{k} e^{z_k}}$$</li><li>定義域が$(-\infty,+\infty)$の変数を$(0,1)$に写す関数。単調増加関数だが上限がある。</li><li>任意の実数値を取りうる変数を確率的な変数に規格化したい時に用られる。</li><li><a href="#multiclass-classification">Multiclass classification(多クラス分類)</a>のニューラルネットの出力層のニューロンの活性化関数として使われるケースが多い。</li><li>出力層の7個のニューロンのそれぞれの入力総和が
$$
\mathbf z = \left(
              \begin{array}{c}
                1\\
                2\\
                3\\
                4\\
                3\\
                2\\
                1\\
              \end{array}
            \right)
$$
であるとき、これらのニューロンの入力総和に対する個々のソフトマックスは
$$
\mathbf{\sigma(\mathbf{z})} = \left(
              \begin{array}{c}
                0.0236\\
                0.0643\\
                0.1747\\
                0.4748\\
                0.1747\\
                0.0643\\
                0.0236\\
              \end{array}
            \right)\\
$$
同時に
$$
0 \le \mathbf{\sigma}_i \le 1\\
\sum_i \mathbf{\sigma}_i = 1
$$
となる。<br/>ソフトマックスの入力の内、最も値が大きいものの出力が強調され他の出力と大きく差をつけられることから
多クラス分類のような複数のクラスから1つのクラスを選択する場合の分類に向いている。</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="sigmoid"></a><h4>Sigmoid function - シグモイド関数</h4><h6>特徴</h6><ul class="features"><li>$$s(\mathbf{z})_j = \frac{1}{1+e^{-z_j}}$$</li><li>$$s' = s(1-s)$$</li><li>ソフトマックス関数と同様に、定義域が$(-\infty,+\infty)$の変数を$(0,1)$に写す関数。単調増加関数だが上限がある。</li><li><a href="#multiclass-classification">Multilabel classification(マルチラベル分類)</a>のニューラルネットの出力層のニューロンの活性化関数として使われるケースが多い。</li><li>シグモイドはソフトマックスと異なり、入力されたベクトルの成分の和で個々の成分を割り成分の総和が1となるような規格化は行わない。
そのため多クラス分類のようにあり得る複数のクラスの中から1を選ぶような分類には適さない。
代わりに、出力層のニューロン個々が独立した確率であるようなマルチラベル分類に適している。</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="multiclass-classification"></a><h4>Multiclass classification - 多クラス分類</h4><h6>特徴</h6><ul class="features"><li>MNISTのようにmutually exclusiveな値の分類。</li><li>1つの入力に対して複数のクラスの中から1のクラスが割り当てられるような分類</li><li>ニューラルネットでは入力に対する真の出力が下記のようなone-hot vectorとなるような分類
$$
\mathbf y = \left(
              \begin{array}{c}
                0 \\
                0 \\
                0 \\
                1 \\
                0 \\
              \end{array}
            \right)
$$</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="multilabel-classification"></a><h4>Multilabel classification - マルチラベル分類</h4><h6>特徴</h6><ul class="features"><li>Not mutually exclusiveな分類。</li><li>1つの入力に対して複数のクラスが割り当てられるような分類</li><li>例としてトピックラベルのように一つの記事に複数のタグをつける場合に使われる分類</li><li>ニューラルネットでは入力に対する真の出力が下記のようなベクトルとなるような分類
$$
\mathbf y = \left(
              \begin{array}{c}
                0 \\
                1 \\
                0 \\
                1 \\
                0 \\
              \end{array}
            \right)
$$</li></ul></div><div class="paragraph"><a class="in-page-anchor" id="hadamard-product"></a><h4>Hadamard Product - アダマール積</h4><h6>特徴</h6><ul class="features"><li>同じ形状の2つの行列に対して、それぞれの成分を掛けあわせた同型の行列を作る操作。</li><li>$$
\begin{pmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{pmatrix}
\circ
\begin{pmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{pmatrix}
=
\begin{pmatrix} a_{11} b_{11} & a_{12} b_{12} \\ a_{21} b_{21} & a_{22} b_{22} \end{pmatrix}
$$</li><li>$$(A \circ B)_{i,j} = a_{i,j} b_{i,j}$$</li><li>畳み込みニューラルネットワーク(CNN)において、生の入力からfeature map(Activation map, Convolved feature)を作る際に利用される演算。</li></ul></div></article><script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
inlineMath: [['$','$']],
processEscapes: true
},
CommonHTML: {matchFontHeight: false },
displayAlign: "left",
displayIndent: "2em"
});

</script></main></div><script src="js/main.js?8fc1038fbd" data-turbolinks-track="reload"></script><script src="js/raw/analytics.js" data-turbolinks-track="reload"></script></body></html>