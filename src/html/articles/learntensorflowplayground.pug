include ../common/mixin

article.main-article(data-page='page-learntensorflowplayground')
  a#preface-part.in-page-anchor
  h1#preface-part(data-paragraph='はじめに') TensorFlow Playgroundの仕組み
  +article-header('2017-02-14')

  .paragraph
    p
      | TensorFlow Playgroundの本家サイトは
      a(href='http://playground.tensorflow.org', target='_blank') こちら。
      br
      a.tensorflowplayground-japanese(href='raw/learntensorflowplayground/index.html' target='_blank')
        |  本家のTensorFlow Playgroundの日本語訳
      | を作成しましたので、本サイトと合わせてご覧ください。
    p
      | TensorFlow Playgroundとは何かを言葉で説明するより一度自分の目で直接見るほうが早いので、
      | 上記のリンクをクリックしてTensorFlow Playgroundを開き、思いつくままいろいろ自分で試してみてください。
    p
      | このWebサイトは機械学習、ニューラルネットワークに興味を持ちTensorFlow Playgroundを触ってより深くこれらの仕組みを知りたくなった方を対象にしています。 機械学習に関するWebサイトは最近ものすごい勢いで増えており、図や数式を交えた分かりやすい説明が簡単に読めるようになってきました。 ですが、習うより慣れろで実際に手を動かして機械学習をプログラムしてみるのが一番です。
    p
      | 機械学習でポピュラーなプログラミング言語pythonを一から勉強し機械学習のソースコードを書く、となると途中で力尽きる人が大半だと思います。 TensorFlow Playgroundは自分でプログラミングをする必要なく機械学習、ニューラルネットワークの仕組みを目で見て手で動かして直感的に理解できる非常に優れたツールです。 なおTensorFlowはGoogleの開発した機械学習フレームワークですが、このTensorFlow Playground自体はTensorFlowを利用しておらず、 すべてブラウザ上のJavascriptで動作しています。
    p
      | 私自身は機械学習の研究者でもなく、関連した仕事をしているわけでもありません(そういった仕事に興味はありますが)。 ですのでところどころ誤りや間違いが見つかると思います。 もし誤りを見つけられましたら
      a(href='https://twitter.com/h1nase', target='_blank') 私のツイッター
      |  までご連絡ください。
  .paragraph
    a#reference-part.in-page-anchor
    h2#reference-part(data-paragraph='') 参考文献
    hr
    p
      | はじめにこのサイトを作るにあたって参考にした資料を載せておきます。 ここで解説する内容は大なり小なりこれらのサイトの解説を自分の言葉でまとめ直したようなものです。 私の拙い文章が分かりにくいと感じたらこれらの参考文献を直接読んでいただいてかまいません。
    ul
      li
        a(href='https://drive.google.com/file/d/0B04ol8GVySUubjVsUDdXc0hla00/view', target='_blank') Neural Network TensorFlow入門講座
      li
        a(href='https://cloudplatform-jp.googleblog.com/2016/07/tensorflow-playground.html', target='_blank') TensorFlow Playgroundでわかるニューラルネットワーク
      li
        a(href='http://neuralnetworksanddeeplearning.com/index.html', target='_blank') Neural Network and Deep Learning
      li
        a(href='http://www.deeplearningbook.org/', target='_blank') Deep Learning An MIT Press book
    p
      | 先頭の丸山氏による「Neural Network TensorFlow入門講座」は初学者でも非常に理解しやすい内容になっています。 パワーポイントでニューラルネットワークの基礎について非常にわかりやすくまとまっていますので一度目を通してみることをおすすめします。
      br
      |  上から２番目のGoogleの佐藤氏による「TensorFlow Playgroundでわかるニューラルネットワーク」と本サイトはTensorFlow Playgroundを 題材としている点でコンセプトは似ていますが、こちらのサイトはニューラルネットワーク本論よりかはPlayground上の用語や仕組みの解説に 重きをおいています。
      br
      |  3番目の「Neural Network and Deep Learning」はMichael Nielsen氏による英文のドキュメントです。私のWebサイトで使う数式は こちらのサイトの説明をかなり参考にしています。文章自体もユーモアがふんだんに取り入れられた、技術解説サイトとは思えない素晴らしいWebサイトです。
      br
      |  4番目の「Deep Learning」は非常に詳細にDeep Learningについて解説しています。文量が非常に多く私もまだ全て読み終えていませんが、 内容を全て理解できればディープラーニングの基礎が身についていると言っても過言ではないと思います。無料で読めるHTML版の他に、米国amazonでは 印刷された本が販売されています。2017/2/7現在amazonのAI分野でベストセラーとなっていました。
    p  このサイトの言い回しや例えは上記の参考文献の影響を多大に受けています。似たような言い回しがいくつか見つかると思いますがご容赦ください。
  .paragraph
    a#summary-part.in-page-anchor
    h2#summary-part(data-paragraph='') Playgroundの仕組み概要
    hr
    .centering
      a.tensorflowplayground-japanese(href='http://playground.tensorflow.org/', target='_blank')
        img.playground-screenshot(src='image/learntensorflowplayground/screenshot.png', alt='screenshot')
    p
      | 上の図はTensorFlow Playgroundのスクリーンショットです。上部に学習率や活性化関数などの全体的な設定が、左側には学習させるデータの設定が、 真ん中に四角いボックスで表されたニューロン、およびニューロンで構成されたニューラルネットワークが、そして右側にニューラルネットワークの最終的な出力結果 が表示されています。これらの詳細は後ほど解説します。
    p
      | 左上にある再生(▶)ボタンを押すと機械学習が始まります。右側の出力結果の平面上に点在した赤と青の点々に沿うようにヒートマップの色が変化していく様子が見れるはずです。 そして点々の色とヒートマップの色の分布が互いに近づいてくるに従って誤差の数値が小さくなる様子も確認できるはずです。
      br
      |  TensorFlow Playgroundのニューラルネットワークは、事前にプロットされた赤と青の点々の分布を学習し、これらの点がどのような規則に従って分布しているのかを 推測しようとします。
    .centering(style='float: right;')
      img(src='image/learntensorflowplayground/varying-output.gif', alt='varying output')
    p  ダーツを例に別の角度から説明します。
    p
      | 壁に正方形の板と取り付けてダーツを投げ、当たった場所によって得点が変わるゲームがあるとします。
      br
      |  また、どこに当たれば何点というのは事前に分かっておらず、投げたダーツは必ず板のどこかにあたるものとします。
      br
      |  さらに得点は-1点から+1点の間の値をとるものとします。
    p
      | TensorFlow Playgroundでは「どこにダーツを投げれば何点入るか」を、いくつかダーツを投げてみて推測します。
      br
      |  ダーツを投げて+1点であればその点を青で塗り、-1点であれば赤で塗ります。
      br
      |  当然板のすべてのありとあらゆる場所に隙間なくダーツを投げてデータを取れば推測する必要もなく確実な結果が分かりますが、
      br
      |  現実的に無限回ダーツを投げて全ての座標についてデータを取るのは不可能です。
      br
      |  いくつかの学習用データサンプルを元にダーツの得点分布を機械学習で推定してしまうのがTensorFlow Playgroundです。
      br
      |  言い換えると板上の各座標 $x,y$ についてダーツの得点分布 $f(x,y)$ を機械学習によって推定します。
      br
      |  もっとも、データの標本を元に真の分布を推測する手法自体は統計学で扱うポピュラーな手法でありTensorFlow Playground独自の話ではありません。
      br
      |  TensorFlow Playgroundでは、統計分析の手法としてフィードフォワード型ニューラルネットワーク(多層パーセプトロン, MLP)を使い 機械学習させることによって真の分布を推定します。
    p
      | TensorFlow Playgroundは教師あり学習をモデルにしています。
      br
      |  これは、入力(今回は $x,y$ 座標)に対して正解の出力($f(x,y)$)が紐付いたデータサンプルがいくつか事前に用意されている機械学習モデルです。
      br
      |  TensorFlow Playgroundの出力の平面にプロットされた赤と青の点々が、その学習用のデータサンプルです。
      br
      |  これらのサンプルを使い、問題と回答のデータを学習させることでネットワークを鍛えています。
      br
      |  学習用サンプルを使ってある程度ネットワークが鍛えられると、$x,y$の入力から$f(x,y)$を高い精度で推定できるようになります。
    p
      | このようにしてみるとまるで統計学の勉強をしているような錯覚に陥るかもしれません。機械学習といえば、例えば猫の画像を読みこませるとコンピュータが それを猫だ、と判定する画像認識や、手書き文字認識、音声認識で世間を騒がせています。 ダーツの得点分布が分かることと機械が猫を認識できるようになることとどういう関係あるのか、これが理解できるようになるためにはある程度数学的な 解説が必要になってきます。
      br
      |  このサイトではなるべく数式に頼らない説明を心がけていますが、一歩深く踏み込むためには必要最小限の数学が必要になることを覚悟しておいてください。
    p
      | 機械学習の何がセンセーショナルだったかというと、コンピュータが画像や音声などの非構造化データの高い精度での認識に成功したことです。
      br
      |  コンピュータはこれまで構造化データの処理に力を発揮してきましたが、非構造化データまで扱えるようになったことで多くの人を驚かせました。 非構造化データに対する構造化データとは、あるデータに対してコンピュータにこのデータはどういうデータだという情報をデータ本体とは別に持たせたデータのことです。 例えば&quot;東京都千代田区1-1-1&quot;という文字列を見ると、これはすぐに日本のどこかの住所だな、我々人間には分かりますが、 コンピュータは単なる文字列としか認識できません。そのためコンピュータがこれを住所と認識するためには
      br
      |  &quot;東京都千代田区1-1-1&quot; : &quot;住所&quot;
      br
      |  などのようにこの文字列は住所を表している、という情報を別途人間が付与する必要がありました。 皆様お馴染みのエクセルにしても、データを集めたシートを作る際に先頭一行にヘッダーを設ける場合が多いと思います。
      br
      |  例えばエクセルで下記のようなデータを作るとします。
    table
      tr
        td 郵便番号
        td 電話番号
        td 氏名
      tr
        td 000-1111
        td 000-0000-0000
        td 鈴木太郎
      tr
        td 111-0000
        td 111-1111-1111
        td 佐藤一郎
      tr
        td 999-1234
        td 03-0000-0000
        td 田中三郎
    br
    p
      | この場合、一行目のヘッダにその列データの意味の情報が付与されています。
      br
      |  これが構造化データの一例です。データに対して、そのデータが何を意味するものかあらかじめ人の手によってラベルづけされています。
      br
      |  対する非構造化データとは、これらのヘッダがないデータと考えてください。画像、音声は非構造化データの代表例ですが、 上の表についてヘッダを取り除いた場合これも非構造化データとなります。この場合、「000-1111」は郵便番号のような感じもしますが、 コンピュータは事前にこれが郵便番号とは知らないので、上の表から郵便番号を取ってこいとコンピュータに指示をしてもコンピュータは どれが郵便番号か分かりません。
    p  機械学習はこういった非構造化データを人力に頼らずコンピュータ自身でデータを構造化するための効率の良い仕組み、と考えるとよいでしょう。
    details#regard-nn-as-func
      summary 補足: ニューラルネットワークを関数としてみる
      p
        | 上ではダーツを例にしましたが、もう少し一般化しましょう。
        br
        |  ニューラルネットワークとは、入力ベクトル $$ \boldsymbol{x} = \begin{pmatrix} x_1 \\ x_2 \\ ... \\ x_n \end{pmatrix} = \{\boldsymbol{x} \mid \boldsymbol{x} \in \mathbb{R^n} \} $$ を受け取り、出力ベクトル $$ \boldsymbol{f}(\boldsymbol{x}) = \{\boldsymbol{f} \mid \boldsymbol{f} \in \mathbb{R^m} \} $$ を返す関数と見ることができます。
        br
        |  ダーツの例に当てはめると、 入力ベクトル: $ \boldsymbol{z} = \begin{pmatrix} x \\ y \end{pmatrix}; x,y \in \mathbb{R} $ に対して、出力ベクトル: $f(\boldsymbol{z}) = \{ f \mid f \in \{1,-1\} \}$ となります。
        br
        |  ダーツの例では出力は-1か+1の2通りで、1次元ベクトル=スカラー値です。
      p
        | ネットにはMNISTデータベースを使って手書きの数字を機械学習でコンピュータに認識させる機械学習チュートリアルがたくさんありますが、 MNISTのケースでは入力ベクトルは手書き数字のビットマップ画像のビット列のベクトル、 出力ベクトルは入力した手書き画像の数字が$i$である確率$P_i$を$i=0からi=9まで並べた$ 確率ベクトル$(P_0,...,P_9)$になります。
        br
        |  ただし、確率ベクトルから最も確率の大きい1つを抜き出したものを出力ベクトルとするものもあります。
      p
        | このように、現実世界の問題をうまく入力ベクトル・出力ベクトルにモデル化することができれば機械学習で驚くような結果が得られる可能性があります。
        br
        |  機械学習の基礎をマスターすることができれば、応用事例は自分のアイデア次第になります。 この「自分のアイデア次第」という部分が私達のように機械学習を勉強する人の大きなモチベーションなります。
      p
        | 機械学習では、上に書いた出力関数 $f$ の形状をサンプルデータの学習を通じて推測しようとします。
        br
        |  ニューラルネットワークではこの$f$の形状は主にニューロンの重み $w$ とバイアス $b$ で決まります。
        br
        |  それ以外に活性化関数$\phi$というフィルターの役割を持つ関数も$f$の形状に寄与します。 この辺りについては後ほど説明します。
        br
        |  いずれにしろ、ネットワークを関数として見るというのは非常に新鮮な感覚です。
    p  より詳しい説明に移る前に、ニューラルネットワークの概観や画面に表示されているいくつかの設定項目について説明します。
  .paragraph
    a#learningsettings-part.in-page-anchor
    h2#learningsettings-part(data-paragraph='') ニューラルネットワークについて
    hr
    p
      | 巷には非常にわかりやすくまとまったWebサイトが溢れているため このサイトではニューラルネットワークについてゼロから解説することはしません。 ニューラルネットワークの概要を知りたい方は参考文献の欄にも記載した
      a(href='https://drive.google.com/file/d/0B04ol8GVySUubjVsUDdXc0hla00/view', target='_blank') Neural Network TensorFlow入門講座
      |  を一読ください。
      br
      |  英語が読める方は
      a(href='http://neuralnetworksanddeeplearning.com/index.html', target='_blank') Neural Network and Deep Learning
      |  もおすすめです。
    p
      | ここではTensorFlow Playgroundを理解するのに最低限必要な前提知識としての説明に留めます。
      br
      |  ニューラルネットワーク(多層パーセプトロン, MLP)は入力層、隠し層、出力層の3種類の層からなっています。
    .centering
      img(src='image/learntensorflowplayground/network-layers.png', alt='network layers')
    p
      | 何を入力とするか、何を出力として得たいかの機械学習モデルができると、入力層と出力層については層の中のニューロンの数やベクトルの要素の意味などが定まります。
      br
      |  例えばダーツの例では入力ベクトルはダーツを当てるx,y座標、出力ベクトルはその座標にダーツを当てた時に得られる得点です。 MNISTの手書き数字認識の場合は入力ベクトルは手書き数字の画像のビット列、出力ベクトルは0〜9のどの文字であるかの確率です。
      br
      |  ですが、隠し層については機械学習モデルが定まったあともすぐには決められません。モデルにより隠し層の層の数はいくつか最適なのか、それぞれの層の中の ニューロンの数はどのくらいが良いのかは経験や試行錯誤の上決まっているようです。
    p
      | 隠し層の数やニューロンの数を増やせば、ネットワークのパラメータが増えるためネットワークが柔軟になりますが、 同時にパラメータの計算コストが上がるため、単純に数を増やせばよいわけではありません。
    .centering
      img(src='image/learntensorflowplayground/configure-hidden-layer.png', alt='configuring hidden layer')
    p
      | TensorFlow Playgroundでは上図中のプラス(+)ボタンとマイナス(-)ボタンで隠し層の数や、層の中のニューロンの数を加減できます。 隠し層の数を増やせばヒートマップの色分布の収束に時間がかかる様が確認できると思います。
    .centering
      img.img-perceptron(src='image/learntensorflowplayground/perceptron.png', alt='perceptron')
    div
      img(src='image/learntensorflowplayground/neuron.png', alt='neuron', style='display: block; float: right;')
      p
        | 隠し層の中には1個以上のニューロンが存在します。TensorFlow Playgroundでは右に示したような四角いボックスの1つ1つがニューロンです。
        br
        |  ニューロンは上のシンプルな画像にあるように複数の入力値を受け取り、一つの値を出力するシンプルな計算ユニットです。
        br
        |  右のTensorFlow Playgroundのニューロンを見ると、四角の左側に何本かの線が見えますがこれがニューロンの入力に当たります。 四角の右側に見える線はニューロンの出力です。よく目を凝らしてみると四角の左下に似たような小さな四角がついているのが見えますが、これが ニューロンのもつバイアスです。
      p
        | こうして図を見ると、ニューロンは人間が情報を認識する仕組みと似ているように思えます。 バイアス(偏見)が非常に強い人は、誰がどういうことを言っても(どんな情報を入力しても)偏見に基づいたアウトプットしかできず、 逆に偏見がなく個々の情報を総合的に判断してアウトプットする人もいます。 さらに、伝えられる情報についてどの情報が重要でどの情報が重要でないかの重みをうまくつけられるスマートな人もいるでしょう。 また、入力された情報に対して一切重みづけをせず、聞いたままを鵜呑みにして次の人に伝達する人もいますよね。
      p
        | ニューロンの出力は、
        br
        |  入力を$\boldsymbol{x} = (x_1,x_2,...,x_i,...x_n)$、
        br
        |  それぞれの入力につける重みを$\boldsymbol{w} = (w_1,w_2,...,w_i,...,w_n)$、
        br
        |  ニューロンのバイアスを$b$、
        br
        |  活性化関数を$\phi$
        br
        |  とすると、次のように表されます。
        br
        |  出力$\phi = \phi\left(\displaystyle \sum_{i}^{n} \left(w_i * x_i\right) + b \right) = \phi\left( \boldsymbol{w} \cdot \boldsymbol{x} + b\right)$
        br
        |  活性化関数はニューロンの出力をフィルタリングする機能を持つ関数で機械学習をスタートさせる前にあらかじめどのような 関数を使うか決めておく必要があります。
        br
        |  TensorFlow Playgroundでは初期値は$$\phi(z) = tanh(z)$$になっています。
        br
        |  $tanh(z)$は単調増加な関数で値域が$(-1,1)$です。 ですので活性化関数に$tanh(z)$を選択した場合、ニューロンの入力総和が大きいほど出力も大きくなりますがニューロンの出力は-1から+1の範囲に収まります。 TensorFlow Playgroundでは他に数種類の活性化関数を選ぶことができます。活性化関数については後ほど解説します。
      div(style='clear:both; display: table;')
    p
      | ニューラルネットワークの説明に戻ります。
      br
      |  ニューロンの出力は次の層のニューロンの入力になります。そのため層と層の間でニューロン同士がネットワークを構成しているように見えます。 このようなネットワーク層はFully-Connected Layer(FCL)と呼ばれます。
    .centering
      img.img-neural-network(src='image/learntensorflowplayground/neural-network.png', alt='neural network')
    p
      | 各々のニューロンの出力値はひとつだけ定まり、次の層の複数のニューロンに入力されます。 次の層のニューロンは前の層の全てのニューロンからの出力を入力値として受け取り、それぞれに重みをつけ、バイアスを加えて次の層のニューロンに渡します。
    p
      | ニューロンの重み、バイアスはニューロンごとに独立しているため、同じ層に並んでいる全てのニューロンは受け取る入力値こそ同一ですが、 重みとバイアスがそれぞれ異なるため結果として各々のニューロンの出力にはニューロンそれぞれの個性が現れます。
    p
      | これは上司が複数の部下から話を聞き、どの部下の話がどのくらい信用できるか評価し、部下の話とは独立した自分独自の知識(バイアス)をミックスして 次の上司に話をしに行く様と似ています。その上司は同様に、エスカレーションされた複数の話と自分の知識を総合的に判断し、さらに上へと情報を上げます。 部下の話をどう評価するか、上司自身の持つバイアスはどのくらい大きいのかによって、同じ部下から聞いた話でも上への情報の上げ方が変わってきます。
    p
      | 機械学習の「学習」というのは、全ニューロンの重み$w_i$、バイアス$b$を反復計算によって最適化することです。 ここでいう最適化とは、あらかじめ正解の出力が用意されたトレーニングデータを入力し 計算して得られた出力と正解の出力の誤差が最小限になるような値を探すことです。
    p
      | 上司と部下の例で言えば、正解を知っている社長がそれとなく一番下っ端の社員に同じ情報を渡し、その上司、さらにまたその上司 へと順々に情報が伝達された結果自分に届いた情報があらかじめ知っている正解と一致するか確かめようと する様子を想像できます。あまりにも正解と届いた情報がずれていれば、社長はその部下の取締役を叱咤し、偏見や評価のやりかたを変えるよう 促します。その取締役はその下の執行役員に、さらに執行役員は部下の部長に、といった具合にトップからボトムの方向に組織を改善しようとします。 トップからボトムへネットワークを改良しようとする計算の流れをバックプロパゲーション、(誤差逆伝搬法)と呼びます。
      a(href='#backpropagation-part') これは後ほど説明します。
    p
      | さて、機械学習の成果はこの最適化された重みとバイアスの数値の組み合わせということになります。 これらの学習済みパラメータのデータは比較的小さなサイズのファイルに収まります。 TensorFlow Playgroundでは多層パーセプトロン(MLP)という形のニューラルネットワークが採用されていますが、この場合 バイアスの数は出力層と隠し層の全ニューロンの数と一致します。重みの数については、層$l$に$k$個のニューロンが配置されている場合、重みのパラメータ数は $$ \displaystyle \sum_{l} \left( k_{l-1} * k_l \right) $$ となります。ただし$k_0$は入力層のニューロンの数とします。
      br
      |  例えば上記の画像のような 4-3-2-2 の構成のネットワークでは、
      br
      |  バイアスの数は $4+3+2+2=11$個、重みの数は$(4*3 + 2*3 + 2*2) = 22$個となります。（入力層、出力層を考慮していないため実際の数字は多少増減します）。 学習済みパラメータとしてはこの33個の数値さえあれば良いことになります。
      br
      |  数値1つに対して4バイト使うとしてもせいぜい100バイトのオーダーのデータサイズになります。
    p  ここまで要約を要約します。
    ul
      li ニューラルネットワークは入力層、隠し層、出力層の3種類の層から成っている
      li それぞれの層にはひとつ以上のニューロンが存在する
      li ニューロンは複数の入力値を受け取り、一つの出力値を返す計算ユニット
      li ニューロンの出力は次の層のニューロンの入力になる
      li 機械学習ではニューロンの重み、バイアスを最適化する
    p  ニューラルネットワークについてより詳しく知りたい方は前述の参考文献をご確認ください。
  .paragraph
    a#about-learning-in-nn-part.in-page-anchor
    h2#about-learning-in-nn-part(data-paragraph='') ニューラルネットワークの学習に関する設定
    hr
    .centering
      img.img-learning-settings(src='image/learntensorflowplayground/learning-settings.png', alt='learning parameter')
    a#learningrate-part.in-page-anchor
    h4#learningrate-part(data-paragraph='') 学習率
    p
      | 学習率は、一度の学習でどの程度重みやバイアスの値を修正するかの率を表します。 学習率が大きいと1度に修正される重み、バイアスの量が大きくなります。 小さくすると重み、バイアスの値を1度に少しだけ修正しようとします。 学習率が機械学習にどのような影響があるのか、TensorFlow Playgroundで確かめてみましょう。 初期値では学習率は0.03に設定されていますが、これを1に変えて再生(▶)ボタンをクリックしてみます。 ネットワークの重みの線の色と太さが初期値の0.03の時と比較して大きいステップで更新される様子が見られるはずです。 逆に0.0003など小さな値にして再実行してみましょう。再生(▶)ボタンの左の反時計周りの矢印ボタンで最初から再実行できます。 この場合、出力や重みの変化がほとんど見られないことが分かります。
    p
      | 参考文献の資料を読んだか既に機械学習についてある程度知識を持っている方であれば下記の勾配降下法の式は何度も目にしているかと思います。 初めて下記の勾配降下法の式を見る人のために式の意味を簡単に説明します。 $$ \begin{align} w&apos; &amp;= w - \eta \frac{\partial C}{\partial w} \tag 1\\ b&apos; &amp;= b - \eta \frac{\partial C}{\partial w} \tag 2 \end{align} $$ の$\eta$が学習率で、0より大きい正の値です。 $C$はコスト関数(誤差関数)で、真の出力と計算結果の出力との誤差の大きさを表す関数です。
      br
      |  このコスト関数の選び方は、誤差の大きさを表現できさえすれば特に決まった選び方はありませんが TensorFlow Playgroundではコスト関数は $$ C = \frac{1}{2} \left(\phi - y \right)^2 $$ としています。
      br
      |  $\phi$: 計算結果の出力
      br
      |  $y$: 真の出力
      br
      |  です。
      br
      |  $C$ をこのようにとると、真の値とニューロンの出力値に差が全く無いときに最小値0となります。
      br
      |  上記$(1),(2)$の式は重み $w$ および バイアス$b$を コスト関数 $C$ が小さくなるような値に更新するという意味を持ちます。 $$ \begin{align} w_{n+1} &amp;= w_n + \alpha \\ b_{n+1} &amp;= b_n + \beta\\ \alpha &amp;= - \eta \frac{\partial C}{\partial w}\\ \beta &amp;= - \eta \frac{\partial C}{\partial b} \end{align} $$ と書くとよりイメージしやすいかと思います。
      br
      |  $\alpha$の値がプラスかマイナスか、はたまたその量はどれくらいかによって$n+1$回目の重み・バイアスの値が変わります。 これから書く話は$w$と$b$を入れ替えても同じですので以下$w_{n+1} = w_n + \alpha$の式に絞って説明を進めます。
      br
    p
      | まずは$\alpha$の符号についてです。 $$ \alpha = - \eta \frac{\partial C}{\partial w}\\ $$ 学習率の定義より$\eta &gt; 0$なので、 $\frac{\partial C}{\partial w}$が正であれば$\alpha$は負の値になります。 つまり、$w_{n+1}$は$w_n$よりも小さな値に更新されます。 言い換えると重み$w_n$を増やした時に誤差$C$が増えるのであれば、次回更新時の$w_{n+1}$を$w_n$よりも小さな数にすれば誤差$C$も減ることになります。
      br
      |  逆に重み$w_n$を増やした時に誤差$C$が減るのであれば、次回更新時の$w_{n+1}$を$w_n$よりも大きな数にすれば誤差$C$も減ることになります。
      br
      |  機械学習の「学習」とは、最終出力誤差$C$を最小にするような全ニューロンの重み$w$とバイアス$b$を見つけることです。ですので、$n \to n+1$の更新で $w_{n+1}$や$b_{n+1}$は誤差$C$を小さくするように値を修正しなければなりません。そのため$\frac{\partial C}{\partial w}$の符号は重要な意味を持ちます。
    .centering
      img(src='image/learntensorflowplayground/learning-curve.png', alt='learning-curve')
    p
      | 次は$\alpha$の量についてです。
      br
      |  先ほどは$\alpha$の符号について書きました。これは$w_{n+1}$を$w_n$から増やすか減らすかを判定するための条件になります。
      br
      |  それでは「どのくらい」増やすか減らすかはどのように制御されるのでしょうか。
      br
      |  ここで登場するのが学習率$\eta$です。学習率$\eta$は0より大きい正の数です。$\eta$を大きく取ると$n \to n+1$のステップ時に ステップ幅が大きくなります。逆に小さな値を取るとステップ幅が小刻みになります。
      br
      |  ステップ幅が小さいと小刻みに$w$の値が修正されていきますが、そのため誤差$C$が0に近づくまでにたくさんの時間を要します。 ステップ幅が大きいと$C$が0に近づく勢いは強いですが、勢いがありすぎて$C = 0$を飛び越してしまうことが頻発します。 最適な学習率はどのくらいなのかは難しい質問です。 直感的には、誤差$C$が大きい時には$\eta$を大きくし、$C$が十分に小さくなったあとは$\eta$を小さな値にして微修正をして誤差0に近づける、 といった方法もありそうです。 私が調べた範囲では機械学習を始める前から「これがベストな学習率$\eta$の値だ」と決められるものではないようです。
    a#activator-part.in-page-anchor
    h4#activator-part(data-paragraph='') 活性化関数
    .centering
      img.img-perceptron(src='image/learntensorflowplayground/perceptron.png', alt='perceptron')
    p
      | 活性化関数はニューロンの出力をフィルタリングします。 ニューロンは上図の通り一つ前の層のニューロンの出力の総和を重み・バイアスを元に計算し、それを活性化関数に通して出力値を確定します。 $$ \phi = \phi(z) = \phi\left( \sum_{i} \left(\ w_i x_i \right) + b \right) $$ TensorFlow Playgroundでは$\phi$の初期値としてtanhが設定されています。
    p
      | 他にもReLU, シグモイド関数、線形関数の選択肢があります。
      br
    table.activators
      thead
        tr
          td グラフ
          td 活性化関数
          td 式
          td 値域
          td 導関数
      tbody
        tr
          td
            img(src='image/learntensorflowplayground/tanh.png', alt='tanh')
          td $tanh(z)$
          td $$\phi(z)=\frac{e^{-z} - e^z}{e^{-z} + e^z}$$
          td $(-1,1)$
          td $\phi&apos;(z)=1-\phi^2(z)$
        tr
          td
            img(src='image/learntensorflowplayground/ReLU.png', alt='ReLU')
          td $ReLU(z)$
          td $$\phi(z)=\frac{1}{2} \left(|z| + z\right)$$
          td $[0,\infty)$
          td
            | $\phi &apos;(z)=\begin{cases} 1, &amp; \text{for $z$ &ge; 0 } \\ 0, &amp; \text{for $z$ &lt; 0 } \end{cases}\\$
        tr
          td
            img(src='image/learntensorflowplayground/sigmoid.png', alt='sigmoid')
          td $sigmoid(z)$
          td $$\phi(z)=\frac{1}{1+e^{-z}}$$
          td $(0,1)$
          td $\phi&apos;(z)=\phi (z) \cdot \left(1 - \phi (z)\right)$
        tr
          td
            img(src='image/learntensorflowplayground/linear.png', alt='linear')
          td $Linear(z)$
          td $$\phi(z)=z$$
          td $(-\infty,\infty)$
          td $1$
    p
      | 活性化関数は、
      a(href='https://en.wikipedia.org/wiki/Activation_function', target='_blank') Wiki - Activation function
      |  にあるように様々な選び方があります。活性化関数自体の形以外に、活性化関数の導関数も活性化関数を決める重要なファクターです。 詳しくは
      a(href='#backpropagation-part') バックプロパゲーション
      | の項に書きます。
    a#regularization-part.in-page-anchor
    h4#regularization-part(data-paragraph='') 正則化、正則化項
    p
      | 正則化を理解するためには、まず過学習(over-fitting)について知る必要があります。
      br
      |  ダーツの学習用データ(トレーニングデータ)を使って十分に訓練したニューラルネットワークがあるとします。 トレーニングデータについて、ニューラルネットワークの計算結果の出力と真の出力と誤差が十分ゼロに近づいたので、 あなたは未知の座標$(x,y)$について出力の得点$f(x,y)$が十分な精度で予測できるだろうと考えました。 試しに適当な座標$(x&apos;,y&apos;)$にダーツを投げたら得点はどうなるかニューラルネットワークに問い合わせてみました。
      br
      |  すると、客観的に見て明らかに誤った得点が返答されました。十分に学習させたはずのニューラルネットワークなのに何故&mldr;。 これが過学習です。トレーニングデータに対してのみネットワークのパラメータ(重み、バイアス)が最適化されているので、 トレーニングデータに&quot;似ていない&quot;新しいデータを入力したときに、誤った出力をネットワークが返してしまう問題です。
    p
      | これは世論調査などの統計でも想像しやすい話です。アイドルの好感度調査をする際に、アイドルのライブイベント会場でアンケートをとると いくら大量の回答を集計したとしても、&quot;世間一般&quot;のアイドルの好感度とはフィットしない統計結果が生まれる可能性が高くなります。
    p
      | TensorFlow Playgroundで意図的に過学習を起こすことは簡単です。
      br
      |  画面左側の「トレーニングデータの割合」を10%まで下げてみましょう。ちなみにトレーニングデータとテストデータについては
      a(href='#ratio-of-training-data-part') ここで説明しています。
      |  簡単にいうとトレーニングデータの割合を10%にすると、入力に対して答えの出力が分かっているデータの10%をトレーニングデータにまわし、 残りの90%をテストデータに回すことになります。トレーニングデータは重み$w$やバイアス$b$を修正するために使われますが、 テストデータは重みやバイアスを修正せず、誤差を計算するためだけに使われます。
      br
    .centering
      img(src='image/learntensorflowplayground/example-of-overfitting.png', alt='Example of over-fitting')
    p
      | 上図はトレーニングデータの割合を10%にしたものと50%にしたものでのTensorFlow Playgroundの出力結果の違いです。 2つともトレーニングデータの誤差についてはほぼ0に近い数字になっていますが、トレーニングデータの割合が10%のものは テストデータの誤差が非常に高く、ヒートマップも不自然な形になっています。 これはトレーニングデータのみにフィットするようニューラルネットワークがパラメータを調整した結果です。
    p
      | 過学習が発生すると、十分に小さなトレーニングデータの誤差に対して、テストデータの誤差が小さくならない現象が発生します。 上図の左を見れば、トレーニングデータのオレンジ・ブルーの点の分布とヒートマップの分布は確かに間違ってはいないことが分かります。
    .centering
      img(src='image/learntensorflowplayground/example-of-overfitting2.png', alt='Example of over-fitting')
    p
      | 上の図ではテストデータが表示されたヒートマップを並べてみました。右の枠の色が濃い点々がテストデータです。 トレーニングデータについては色の分布がきちんとフィットしていますが、学習に使っていないテストデータで誤差を確かめると かなりズレがあることが分かります。
    p
      | 過学習が機械学習で問題になるのは、トレーニングデータの誤差が十分に0に近づいてしまうとニューロンの重みやバイアスが それ以上ほとんど更新されなくなってしまうことです。
      br
      |  機械学習ではトレーニングデータの誤差$C$を小さくするように重み$w$とバイアス$b$を反復修正しますが、 誤差$C$が十分小さくなると学習率の欄で説明した $$ \frac{\partial C}{\partial w} ,\, \frac{\partial C}{\partial b} $$ の値が小さくなります。つまり $$ w&apos; - w = -\eta \frac{\partial C}{\partial w} \to 0\\ b&apos; - b = -\eta \frac{\partial C}{\partial b} \to 0 $$ となり、これ以上学習が進まなくなってしまうのです。
    p
      | それでは過学習を防ぐためにはどうすればよいでしょうか。
      br
      |  すぐに思いつくのはトレーニングデータの数を増やすこと、データの偏りが無いように注意を払うことです。 しかしこれらをしなくとも、過学習を防ぐための仕組みがあります。
    p  それが正則化(Regularization)と呼ばれるテクニックです。
    p
      | TensorFlow Playgroundでは2つの正則化方式を選択できます。L2正則化とL1正則化です。
      br
      |  L2正則化もL1正則化も誤差関数$C$に正則化項を加えるだけのシンプルなオペレーションです。
    p
      | L2正則化: $$ C&apos; = C_0 + \frac{\lambda}{2 n} \sum_{w_i \in all} w_{i}^2 $$ L1正則化: $$ C&apos; = C_0 + \frac{\lambda}{n} \sum_{w_i \in all} |w_i| $$ ここで、$C_0$はオリジナルの誤差関数です。TensorFlow Playgroundでは $C_0 = \frac{1}{2}\left( \phi - y \right)^2$ となっています。
      br
      |  $\lambda$は正則化項の大きさをスケールさせる係数で、$\lambda \gt 0$です。TensorFlow Playgroundでは0から10までの値が設定可能です。 $\lambda$を0にすると正則化項が存在しないものと同じことになります。($\lambda=0$を選択できるようにしている理由は私はよく分かりません)。 $\lambda$の値を大きくすると誤差関数における正則化項の影響が大きくなります。
      br
      |  $n$はトレーニングデータのサンプル数であることが多いようですが、TensorFlow Playgroundでは$\lambda$の中に含めているようで$n$は 計算に出てきませんでした。
    p  正則化されたニューラルネットワークではこの正則化項を加えた修正誤差関数$C&apos;$を小さくする重み$w$およびバイアス$b$を求めることになります。
    p
      | さて、それでは何故正則化が過学習の防止に役立つのでしょうか。
      br
      |  正値($&gt;0$)の正則化項を足したことで、誤差関数$C$はこれまでより$0$になりにくくなったことが分かります。 直感的には常にニューラルネットワークに曖昧さを残しておく機能があるように思えます。 どんなに勉強をしても「もう全て知ってしまったのでこれ以上勉強する必要はない」と思わず 「まだまだ自分には知らないことがある」と考えるようなものです。
    p
      | L2正則化を例により詳しく見てみましょう。 $$ C&apos; = C_0 + C_{\text{reg}}\\ C_{\text{reg}} := \frac{\lambda}{2 n} \sum_{w_i \in all} w_{i}^2 $$ 重み$w_i$の数はニューロンの数を増やせば増やすほど増えますが、ここでは簡単のため重みが2つしかないニューラルネットワークを 考えてみましょう。下の図を見てください。
    .centering
      img#img-regularization(src='image/learntensorflowplayground/L2-regularization.png', alt='L2 Regularization')
    p
      | この図は2つしかない重みについての2次元平面です。重みが3つの時を考える場合はこれが3次元空間に、n個の重みを考えるときは n次元空間になるのですが、4次元空間や5次元空間を図示するのは難しいので簡単のため今回は重みが$w_1$と$w_2$の2つしかない 2次元空間で話をします。
    p
      | 図の$\mathbb{w}^*$というのはオリジナルの誤差関数$C_0$を極小にする極値点です。 言い換えると $$ \frac{\partial C(\mathbb{w}^*)}{\partial \mathbb{w}} = 0 $$ となる点$\mathbb{w}^*$のことです。
      br
      |  過学習は重み$\mathbb{w}$が$\mathbb{w}^*$に落ち込んだ時に発生します。誤差$\dfrac{\partial C_0}{\partial w}$が$0$になってしまっているので $$w&apos; = w - \eta \frac{\partial C}{\partial w} \to w$$ となり$w&apos;$がほとんど修正されなくなります。
    p
      | そこで過学習を防ぐため正則化項 $C_{\text{reg}}$を誤差関数に加え、 $$ C&apos; = C_0 + C_{\text{reg}} $$ とします。
      br
      |  L2正則化では $$ C_{\text{reg}} = C_{\text{reg}}(w_1,w_2) = \frac{\lambda}{2 n} \sum_{i \in \{1,2\}} w_{i}^2 = \frac{\lambda}{2 n} (w_{1}^{2} + w_{2}^{2}) $$ となります。
      br
      |  $C_{\text{reg}}(w_1,w_2)$は $w_1 = w_2 = 0$の時最小値を取ります。また、$f(x,y) = x^2 + y^2$の形の関数の値は 中心0の円の半径 $\sqrt{x^2+y^2}$ の大きさと一致します。上の図の点線の円の大きさは $w_1,w_2$ 平面上の $C_{\text{reg}}$ の大きさを表しています。 上図中では $\tilde{\mathbb{w}}$ が$C_{\text{reg}}$ を最小にする点となります。
    p
      | $C_0$ についても同様に実線の等高線で座標$(w_1,w_2)$における$C_0$の大きさを表現するようにします。 $C_0$の関数形は特定できないですが、ここでは楕円のような形の等高線にしてみます。 これは楕円の円周に沿って重みベクトル$\mathbb{w}$を動かせば$C_0$は変わらないことを意味します。 楕円の長軸方向に沿って$\mathbb{w}$を動かすと$C_0$の変化はなだらかです。 短軸方向に$\mathbb{w}$を動かすと$C_0$は急激に変化します。
    p
      | 仮に$C{\text{reg}}$を考えず、重みが数々の学習を乗り越えて $\mathbb{w} = \mathbb{w^*}$に到達し、 $C_0$が最小値をとってしまった後のことを考えます。
      br
      |  $$ C&apos; = C_0(\mathbb{w_*}) $$ です。この時、重み$w$で偏微分しても点$\mathbb{w_*}$上では微分値は$0$になります。 この状態で上式に $C_{\text{reg}}$ を足してみましょう。 $$ C&apos; = C_0(\mathbb{w_*}) + C_{\text{reg}} = C_0(\mathbb{w_*}) + \frac{\lambda}{2 n} (w_{1}^{2} + w_{2}^{2}) $$ さて、どのように重み$\mathbb{w}$を動かせばトータルの誤差$C&apos;$を小さくできると思いますか？
      br
      |  それは図を見れば明らかです。
      br
      |  正則化項 $\dfrac{\lambda}{2 n} (w_{1}^{2} + w_{2}^{2})$が加わったことで重みベクトル$\mathbb{w}$が原点から遠ければ遠いほど 誤差が大きくなっています。この誤差を小さくするためには$\mathbb{w^*}$に安寧して留まっている重みベクトル$\mathbb{w}$を引っ張りだして 原点方向に移動させなければなりません。 しかしだからといって原点まで $\mathbb{w}$ を持ってきてしまうと今度は$\mathbb{w^*}$ から離れすぎているため$C_0$の値が 大きくなってしまいます。つまり正則化誤差$C&apos;$を最小にする$\mathbb{w}$は$\mathbb{\tilde{w}}$と$\mathbb{w^*}$間の中間に存在することになります。
    p
      | また、$\mathbb{w}$ を$\mathbb{w^*}$から一直線に原点の近くまで動かせば良いものでもありません。 上図の実線の等高線を見ると分かる通り、誤差$C_0$の勾配ががなだらかな経路(緑色の線)と急な経路(青色の線)があります。
      br
      |  オリジナル誤差$C_0$については点$\mathbb{w^*}$から等高線をまたげばまたぐほど値が大きくなってしまうため、 $C_0$の値を抑えたまま$C_{\text{reg}}$を小さくするためにはなだらかな緑の線に沿って重みベクトル$w$を移動させる 必要があります。補正誤差$C&apos;$を最小にする点は点線と実線の等高線の交点上に存在します。
      br
      |  点$\mathbb{\tilde{w}}$と点$\mathbb{w^*}$のどちらに重みベクトル$\mathbb{w}$を寄せるかは正則化項のパラメータ$\lambda$で調整をします。
    p
      | このように、正則化項を加えるとトレーニングデータのみで学習したネットワークに一定量の疑いを差し挟むことになります。 どのくらいトレーニングデータを疑うかの度合いを正則化項のパラメータ$\lambda$で指定するのです。
    a#problemtype-part.in-page-anchor
    h4#problemtype-part(data-paragraph='') 統計モデルの種類
    .centering
      img.img-problem-type(src='image/learntensorflowplayground/problem-type.png', alt='Problem type')
    p
      | TensorFlow Playgroundの画面右上に統計モデルの種類(英語版ではProblem Type)という設定項目があります。初期値は&quot;分類&quot;となっています。
      br
      |  &quot;分類&quot;では上記のダーツの説明でいう得点の値が-1もしくは1の2通りの離散的な値のみとなります。-1,1の間の0.4や-0.8345などの値はありません。
      br
      |  入力した画像が猫であるか猫でないかを0/1で判断するのが分類になります。
    p
      | もうひとつ&quot;回帰&quot;という設定値もあります。こちらは得点の値について-1,1だけのとびとびの離散的な値だけでなく、 その間の-0.529や0.29039などの-1から+1までの連続的な中間値も考慮に入れます。
      br
      |  入力した画像が猫である確率を求める場合はこちらになります。
    .centering
      img(src='image/learntensorflowplayground/classification-regression.png', alt='classification and regression')
    p
      | 左の&quot;分類&quot;の図は点々がブルー(+1)かオレンジ(-1)かの二通りの出力結果のデータの分布です。 対して右の&quot;回帰&quot;の図は+1の点がブルー、-1の点がオレンジであることには変わりありませんが 白味がかった-1と+1の間の中間の値のデータも含まれています。
  #datasetting-part.paragraph
    a#inputdata-part.in-page-anchor
    h2#inputdata-part(data-paragraph='') データに関する設定
    hr
    .centering
      img.img-data-settings(src='image/learntensorflowplayground/data-settings.png', alt='data-settings')
    a#dataselection-part.in-page-anchor
    h4#dataselection-part(data-paragraph='') どのデータセットを使うか
    p
      | TensorFlow Playgroundでは統計モデルの種類が&quot;分類&quot;で4種類、&quot;回帰&quot;で2種類学習させたい分布を選択できます。
      br
      |  これが機械学習で推測させる真の分布です。
      br
      |  排他ORやガウシアンなどのシンプルな分布は何となく容易に分布を推測できそうですが、螺旋分布は正確に分布を当てるのは難しそうです。
    p
      | TensorFlow Playgroundのヒートマップの平面の目盛りを見れば分かる通り、座標 $x,y$ の定義域は$[-6,6]$です。
      br
      |  また、座標$(x,y)$における出力値$f(x,y)$の値域は分類で$f \in \{-1,1\}$、回帰で$f\in [-1,1]$です。
    p  TensorFlow Playgroundで用意されている真の分布について下記の表に特徴をまとめました。
    table#input-dataset-table
      thead
        tr
          td
          td グラフ
          td 名前
          td 式
          td 説明
      tbody
        tr.input-classification
          td(rowspan='4') 分類
          td.dataset-graph
            img(src='image/learntensorflowplayground/input-circle.png', alt='circle')
          td 円
          td
            | $$f(x,y) = \begin{cases}+1; \quad x^2 + y^2 &lt; 2.5^2\\ -1; \quad x^2 + y^2 &ge; 2.5^2 \end{cases}$$
          td.dataset-description
            | 半径2.5の円の内側で+1、外側で-1。ブルーの点のトレーニングデータは半径 $r\in[0,2.5]$、偏角 $\theta\in[0,2\pi)$ からランダムに、オレンジのデータは半径 $r\in[3.5,5]$、偏角 $\theta\in[0,2\pi)$ からランダムに選んで生成される。
        tr
          td.dataset-graph
            img(src='image/learntensorflowplayground/input-xor.png', alt='circle')
          td 排他OR(XOR)
          td $$f(x,y) = \begin{cases}+1;\quad x y &ge; 0\\-1;\quad x y &lt; 0 \end{cases}$$
          td.dataset-description $x,y$の符号が同じなら+1、異なるなら-1。$x$も$y$も点の座標は完全にランダムで生成される。
        tr
          td.dataset-graph
            img(src='image/learntensorflowplayground/input-gaussian.png', alt='circle')
          td ガウシアン
          td
            | $$f(x,y) = \begin{cases}+1; \quad x,y \in N(+2, \text{noise})\\-1; \quad x,y \in N(-2, \text{noise}) \end{cases}$$
          td.dataset-description
            | $N(\mu,\sigma^2)$は平均$\mu$、分散$\sigma^2$の正規分布とする。$x,y$の座標が $\mu=2$、$\sigma^2=$ノイズ(*後述)の正規分布に従う場合+1、$\mu=-2$の正規分布に従う場合-1としている。$x,y$座標は全データサンプルの内半分を前者の正規分布に、残り半分を後者の正規分布に従うよう生成している。
        tr
          td.dataset-graph
            img(src='image/learntensorflowplayground/input-spiral.png', alt='circle')
          td 螺旋
          td
            | $$ \begin{align} \text{Define: } &amp; x=r \sin(\theta),\\&amp; y= r \cos(\theta),\\&amp; r = 5 t,\\&amp; \theta = 1.75 \cdot 2 \pi t + \theta_0 \end{align} $$ $$ f(x,y) = g(t, \theta_0) = \begin{cases} +1;\quad \theta_0 = 0\\ -1;\quad \theta_0 = \pi \end{cases} $$
          td.dataset-description
            | 偏角 $\theta$が増えるに従い半径も増加する螺旋関数。$t \in [0,1]$。全データサンプルの数を$N$とすると、$t_0=0$から$t_{\frac{N}{2}-1}=1$までの$\frac{N}{2}$個の$t$について+1となる点と-1となる点の座標$(x,y)$をそれぞれ生成する。2つの$\frac{N}{2}$ 個のデータサンプルの組の内、 $\theta_0 = 0$の組を+1の点の組、$\theta_0 = \pi$の組を-1の点の組とする。
        tr.input-regression
          td(rowspan='2') 回帰
          td.dataset-graph
            img(src='image/learntensorflowplayground/input-linear.png', alt='circle')
          td 線形
          td $$f(x,y) = \frac{x + y}{10}$$
          td.dataset-description
            | $x$と$y$の値が両方大きければ$f(x,y)$の値は大きく、両方小さければ$f(x,y)$は小さくなる。$f&gt;1$となる$f$については全て$1$としてカウントする。$f&lt;-1$となる$f$についても同様に$-1$とする。
        tr
          td.dataset-graph
            img(src='image/learntensorflowplayground/input-multi-gaussian.png', alt='circle')
          td マルチガウシアン
          td
            | $$ f(x,y) = f(\boldsymbol{x}) = sign * (1 - \frac{D(\boldsymbol{x})}{2}) $$ $$ \boldsymbol{x} = (x,y) $$ $$ D(\boldsymbol{x}) = \min_i |\boldsymbol{\mu}_i - \boldsymbol{x}| $$ $$ \boldsymbol{\mu}_i = \begin{cases} \begin{align} (-4,\, 2.5); \quad &amp;i=1\\ (0,\, 2.5); \quad &amp;i=2\\ (4,\, 2.5); \quad &amp;i=3\\ (-4,\, -2.5); \quad &amp;i=4\\ (0,\, -2.5); \quad &amp;i=5\\ (4,\, -2.5); \quad &amp;i=6 \end{align} \end{cases} $$ $$ sign = \begin{cases} \begin{align} 1;\, &amp;D(\boldsymbol{x}) \text{ で選ばれる } i \text{ が奇数}\\ -1;\, &amp;D(\boldsymbol{x}) \text{ で選ばれる } i \text{ が偶数} \end{align} \end{cases} $$
          td.dataset-description
            | $x,y$座標上の6つの点 $\boldsymbol{\mu}_i$ について、それぞれの点の近傍で$f(x,y)$の絶対値が大きくなる。 $f(x,y)$の符号は$(x,y)$から最も近い$\boldsymbol{\mu_i}$がどれかによって決まる。 これら6つの点のどの点からも離れている座標$(x,y)$では$f(x,y)$の絶対値が小さくなる。 また $D(\boldsymbol{x})$の上限は$2$とし、$D &gt; 2$となる$D$については$D=2$と置き換える。
    a#ratio-of-training-data-part.in-page-anchor
    h4#ratio-of-training-data(data-paragraph='') トレーニングデータの割合
    p
      | TensorFlow Playgroundで学習に用いるデータのサンプル数は&quot;分類&quot;で500個、&quot;回帰&quot;で1200個です。
      br
      |  データサンプルは $(x,y,f(x,y))$ の値の組み合わせです。これが500もしくは1200個用意されます。
      br
      |  これら数百以上のサンプルを用いてネットワークを学習させるのですが、全てのデータを学習に回すわけではありません。
      br
      |  学習され鍛えられたネットワークが本当に正しく学習しているか、誤った方向に学習していないかテストするためのデータサンプルが必要になります。
      br
      |  学習に使うデータサンプルをトレーニングデータ、テストに使うデータサンプルをテストデータと呼びます。
    p
      | テストデータというからには当然入力に対する正しい答えがあらかじめ分かっているデータでなければなりません。
      br
      |  つまりテストデータはトレーニングデータと区別できない同じデータサンプルを使います。
      br
      |  TensorFlow Playgroundでは上図のように数百個のデータサンプルのうち何割をトレーニングデータに回し何割をテストデータに回すか設定できます。 例えばトレーニングデータの割合を60%とすると、上記の例では500個のデータサンプルの内300個をトレーニングデータに、 200個のデータをテストデータに回します。
    p  このように、サンプルデータを分割してトレーニングデータとテストデータに分けて学習の妥当性を検証することを交差検証と呼びます。
    a#noise-part.in-page-anchor
    h4#noise-part(data-paragraph='') ノイズ
    .centering
      img(src='image/learntensorflowplayground/noise-0-50.png', alt='noise comparison')
    p
      | ここで設定できるノイズとは、円やガウシアンなどの選択したデータセットに対してかけるノイズです。 TensorFlow Playground上の画面からはノイズは0〜50まで5刻みで設定できますが、 どのようにノイズをかけるかは選択したデータセットによって変わります。 ちなみにノイズの数値は%単位です。 ガウシアンの分布生成時に分散の値としてノイズを使っていますが、画面上からノイズを50と設定した場合、 分散の値としては0.5が使われます。
    a#batchsize-part.in-page-anchor
    h4#batchsize-part(data-paragraph='') バッチサイズ
    .centering
      img(src='image/learntensorflowplayground/batch-size.png', alt='Batch size')
    p  batch: 1束の、1回分の、ひとまとまりの数
    p
      | バッチサイズは1回の学習(重み、バイアスの更新)を何個のトレーニングデータで実施するかを決める数値です。
      br
      |  例えばバッチサイズを1とすると、トレーニングデータを1つニューラルネットワークに入れるたびに全ニューロンの重み、バイアス を更新しますが、バッチサイズを10とすると10個のトレーニングデータにつき1回パラメータを更新します。
    p
      | ちなみに、TensorFlow Playgroundではエポック(Epoch)というカウンタがあります。
      br
      |
      img(src='image/learntensorflowplayground/epoch.png', alt='Step')
      br
      |  用意された全トレーニングデータをニューラルネットワークに投入しパラメータを更新、修正し終えると機械学習の1サイクル(1エポック)が完了します。 統計モデルの種類が分類の場合、トレーニングデータは500個なので、この500個全部をトレーニングに使い切ると1エポック完了したことになります。 バッチサイズが1の場合、1つのトレーニングデータにつき一回学習(パラメータの更新)をしますので、1エポックで500回学習することになります。 バッチサイズが25の場合は1エポックで20回学習することになります。
    p
      | これまで誤差関数$C$を $$ C = \frac{1}{2} \left( \phi - y \right)^2 $$ と書いてきました。これはトレーニングデータ全体の中の一つのトレーニングデータの真の出力と計算出力の誤差を表します。
      br
      |  実際は全てのトレーニングデータに対して一つの誤差関数を下記のように定めます。 $$ C = \frac{1}{n} \sum_{\boldsymbol{x}} C_{\boldsymbol{x}} $$ ここで$C_{\boldsymbol{x}}$は、ある1つのトレーニングデータで計算される誤差関数の値で、 $$ C_{\boldsymbol{x}} = \frac{1}{2} \left( \phi(\boldsymbol x) - y \right)^2 $$ です。
      br
      |  $n$はトレーニングデータの数です。TensorFlow Playgroundでは統計の種類が分類の時はトレーニングデータは500個用意されているので $n=500$、回帰の時は1200個のトレーニングデータが用意されているので$n=1200$となっています。
      br
      |  トレーニングデータ全体の誤差は個々のトレーニングデータの誤差の平均です。
      br
      |  そのため、勾配降下法で利用する重みやバイアスの補正項はより一般化して書くと $$ \frac{\partial C}{\partial w} = \frac{1}{n} \sum_{\boldsymbol{x}} \frac{\partial C_{\boldsymbol{x}}}{\partial w},\quad \frac{\partial C}{\partial b} = \frac{1}{n} \sum_{\boldsymbol{x}} \frac{\partial C_{\boldsymbol{x}}}{\partial b} $$ となります。この時、重み$w$、バイアス$b$の勾配降下法の式は $$ w&apos; = w - \frac{\eta}{n} \sum_{\boldsymbol{x}} \frac{\partial C_{\boldsymbol{x}}}{\partial w} \\ b&apos; = b - \frac{\eta}{n} \sum_{\boldsymbol{x}} \frac{\partial C_{\boldsymbol{x}}}{\partial b} $$ と書けます。
      br
      |  この式は新たな重み、バイアスを求めるには全てのトレーニングデータについて $\partial C / \partial w$、$\partial C / \partial b$を計算し、 それを$n$で割って平均をとる必要があると言っています。このやり方はトレーニングデータ全体に対する誤差を小さくすることを目的にしていますが、 全トレーニングデータを使った機械学習1エポックあたり1度しかパラメータを更新しないので、学習速度が非常に遅くなります。
    p
      | そこで$m = \{m\,|\,1&le;m&le;n,\,m \in \mathbb{N}\}$となるバッチサイズ$m$を決め、全部のトレーニングデータから $m$個のトレーニングデータをランダムにピックアップし、この$m$個のトレーニングデータについて$C_{\boldsymbol{x}}$の 平均を取りそれを使って重み・バイアスを補正するという方法を考えます。 トレーニングデータ全てのデータから誤差を計算して平均を取ることと、 その中の一部のランダムなm個の誤差の平均を取るのでは大体結果は同じようなものになるだろうという仮定をおいています。 $$ \frac{1}{m} \sum^{m}_{k=1} C_{X_{k}} \approx \frac{1}{n} \sum_{\boldsymbol{x}} C_{\boldsymbol{x}} $$ このようにランダムに$m$個のトレーニングデータをピックアップし勾配降下を計算する方法を確率的勾配降下法(stochastic gradient descent)と呼び、 ピックアップされた$m$個のトレーニングデータはミニバッチ(mini-batch)と呼びます。$m=n$の場合は一部ではなく全トレーニングデータの束で、 バッチ(batch)と呼びます。 全部で$n$個のトレーニングデータから$m$個のミニバッチを重複の無いよう繰り返し取り出してネットワークを更新し、 全てのトレーニングデータでトレーニングが終わるとそこで1エポック終わったことになります。
      br
      |  ちなみにTensorFlow Playgroundの実装では、エポック毎にトレーニングデータをランダムにシャッフルして並び替え、 先頭から順々に$m$個ずつトレーニングデータを取り出して機械学習させています。
  #featuresetting-part.paragraph
    a#feature-part.in-page-anchor
    h2#feature-part(data-paragraph='') 入力するデータの特徴と隠し層
    hr
    .centering
      img(src='image/learntensorflowplayground/input-feature.png', alt='input feature')
    p  まず、入力の特徴(feature)について説明します。
    p
      | 特徴というのは、入力データを表す代表的な値のことです。その値の大きさを特徴量と呼びます。
      br
      |  TensorFlow Playgroundでは座標$x,y$が入力データの特徴ということができます。(後ほど説明しますが、$x,y$のみが特徴になるわけではありません。) これがMNISTの手書き文字であれば各ピクセルの位置とそのピクセルのグレースケールの値を特徴としてとらえることができます。 例えば、30番目のピクセルの色の濃さは200だ、と言った具合です。
      br
      |  いずれの特徴も直接的もしくは間接的に数値で表現できる必要があります。
    p
      | 「車」の特徴について考えてみましょう。車を表す特徴はいくつか想像できます。例えば車の値段、車高、車幅、最高速度、 燃費、色、窓の大きさ、ドアの数、などなど様々な特徴が簡単に思いつきます。
      br
      |  ここで、あなたは自動車メーカーの製品企画部の社員で、新車開発に際して売れる車のコンセプトの提案を求められたとします。 あなたはこれまでに発売された全メーカーの全車種に関するスペックデータ、販売結果のデータなど分析に必要なデータを持っています。 この状態で機械学習のモデルを作るとしましょう。 入力は上に上げた車の特徴になります。そして出力はその車の売上総額とすれば良いとすぐに思いつきます。
    p
      | しかしここで問題があります。ひとえに「車の特徴」と言っても特徴の数が多すぎてどれを入力に使えばいいか簡単には判断できないのです。 例えばデータとして「エアバッグの布の重さは何グラムか」とか「タイヤのボルトの大きさは何ミリか」など「自動車で使われている部品点数」 などの特徴は販売結果にあまり大きな影響はなさそうです。
    p
      | 機械学習を始める前に出力結果に影響を与えそうな入力データの特徴を取捨選択するプロセスは Feature Engineeringと呼ばれます。Feature Engineering自体、多くの研究者の興味の対象になっている非常に重要なプロセスです。 Deep Learning登場以前は、こういった「どの特徴を機械学習の入力に用いれば良いか」はその道のエキスパートにしか うまく判断できませんでした。
    p
      | しかし近年のコンピュータの計算能力の進化やDeep Learningの登場によって、Feature Engineeringを ネットワークに自動で行わせることができるようになりました。つまり、シンプルにありとあらゆるデータを入力すれば、 ニューラルネットワークが自動でデータの特徴を見つけてくれるのです。
    p
      | ニューラルネットワークが自動で特徴を発見してくれるとはいえ、モデルの推計にインパクトのある適切な特徴を選択するプロセスは 現在でも重要です。モデルをうまく表す良い特徴を入力とすれば機械学習の精度やスピードはかなり高まります。 不要な特徴を含んだ入力データで機械学習をしようとすると、非常に大きな数の学習サンプルが必要になってしまうため ある程度人力での特徴選択は現在でも必要です。
    p  TensorFlow Playgroundでは単純な座標$x,y$だけでなく様々な特徴を入力として選択できるようにしています。
    table#input-features
      tbody
        tr
          td
            img(src='image/learntensorflowplayground/f=x.png', alt='feature=x')
          td $$i_x=x$$
          td
            img(src='image/learntensorflowplayground/f=y.png', alt='feature=y')
          td $$i_y=y$$
        tr
          td
            img(src='image/learntensorflowplayground/f=x^2.png', alt='feature=x^2')
          td $$i_{x^2}=x^2$$
          td
            img(src='image/learntensorflowplayground/f=y^2.png', alt='feature=y^2')
          td $$i_{y^2}=y^2$$
        tr
          td
            img(src='image/learntensorflowplayground/f=xy.png', alt='feature=xy')
          td $$i_{xy}=xy$$
          td
            img(src='image/learntensorflowplayground/f=sinx.png', alt='feature=sin(x)')
          td $$i_{\sin x}=\sin x$$
        tr
          td
            img(src='image/learntensorflowplayground/f=siny.png', alt='feature=sin(y)')
          td $$i_{\sin y}=\sin y$$
          td
    p
      | TensorFlow Playgroundでは入力する特徴を一つまたは複数選択できます。例えば、単純に座標$(x,y)$を入力とする場合は、 $i_x=x$の特徴と$i_y=y$の特徴を2つ選択すれば実現できます。
      br
      |  これは次の層に入力される入力層のニューロンの出力が $$w_1 \cdot i_x + w_2 \cdot i_y = w_1 x + w_2 y$$ となり、結果的に下記のように$x$, $y$のニューロンを2つ置くことと同義になっているからです。
    .centering
      img(src='image/learntensorflowplayground/input-layer.png', alt='input layer with feature')
    p
      | 特徴の選択はどのようにすれば良いのでしょうか。これもTensorFlow Playgroundで学べる重要な事柄です。 シンプルに書くと、出力のモデルをうまく説明できるような特徴を選択すれば良いのです。
      br
      |  例えばその増減が出力のモデルに直接影響を与えると考えられるような特徴です。
    p
      | 実際のところ、ニューラルネットワークでは驚くべきことに与えられたデータから特徴を自動で抽出してくれます。 ちなみに、入力層と出力層を含んだ3層以上のニューラルネットワークのことをディープニューラルネットワーク(DNN)と 呼びます。層やニューロンの数が増えるほど柔軟に特徴を抽出することができます。
    .centering
      img(src='image/learntensorflowplayground/network-find-features.png', alt='Network find features')
    p
      | 上の図で入力層の特徴は$i_x = x,\, i_y = y$が選択されています。
      br
      |  また、データセットは円のモデルです。 隠し層の第一層目のニューロンを見てみましょう。これらのニューロンにヒートマップが表示されていますが これはネットワークに$x,y$を与えた時、ニューロンの出力がどのように分布するかを表しています。途中出力のようなイメージです。 1層目のニューロンではオレンジとブルーの点が直線で分けられています。それぞれのニューロンは直線の傾きが異なるだけのように見えます。
    p
      | この時の隠し層第一層目のニューロンの出力を数式で見てみましょう。 $$ \text{output} = \phi (z) = \phi \left( w^{1}_{1,i} x + w^{1}_{2,i} y + b^{1}_{i} \right) $$ ただし、$w^{l}_{j,i}$は層$l$の$i$番目のニューロンが前の層の$j$番目のニューロンにかける重み、 $b^{l}_{i}$は層$l$の$i$番目のニューロンのバイアスとします。 また、活性化関数$\phi$は$\phi(z) = \tanh(z)$とします。
      br
      |  ここで$\tanh(z)$は単調増加な関数で下記に示したような形状をしています。
    table.activators(style='margin-bottom: 10px;')
      thead
        tr
          td グラフ
          td 活性化関数
          td 式
          td 値域
          td 導関数
      tbody
        tr
          td
            img(src='image/learntensorflowplayground/tanh.png', alt='tanh')
          td $tanh(z)$
          td $$\phi(z)=\frac{e^{-z} - e^z}{e^{-z} + e^z}$$
          td $(-1,1)$
          td $\phi&apos;(z)=1-\phi^2(z)$
    p
      | グラフの形状を見れば分かる通り$z=0$で$\tanh(z)=0$、$z&gt;0$で$0&lt; \tanh(z) &lt; 1$、$z &lt; 0$なら$-1 &lt; \tanh(z) &lt; 0$となっています。 ニューロンのヒートマップは出力が0より大きい時にブルー、小さい時にオレンジになります。 ここでブルーとオレンジの点を分ける白の線は$\phi(z) = 0$、つまり$z=0$となる$(x,y)$です。 $$ z = w^{l}_{1,i} x + w^{l}_{2,i} y + b^{l}_i = 0 $$ です。上記の$w x + w&apos; y + b = 0$を満たす線は直線であることが分かります。
      br
      |  これが上記図の隠し層の第一層目のニューロンのヒートマップが直線となっている理由です。 直線の傾きは$w^{l}_{j,i}$の数値によって制御されます。また$b^{l}_{i}$は直線を平行移動させる役割を持ちます。
    p
      | もうひとつ注目すべきことがあります。第一層目のニューロンの出力を表す式 $$ \tanh(w^{l}_{1,i} x + w^{l}_{2,i} y + b^{l}_{i}) $$ ですが、これは入力の特徴としてそっくりそのまま使えてしまうのです。
      br
      |  もちろん重み$w$とバイアス$b$の値は決めておく必要があります。例えば入力する特徴を下記のようにすれば良いのです。 $$ i_{\tanh} = \tanh(3x + 2y + 1) $$ ただ、$\tanh$をそのまま特徴として 入力層に持ってきても特に面白いことはありません。
      br
      |  上のスクリーンショットの隠し層第二層目のニューロンを見てみましょう。
      br
      |
      img(src='image/learntensorflowplayground/neuron-in-hidden-layer.png', alt='Neuron in hidden layer')
      br
      |  この2つのニューロンは下記の数式の産物です。 $$ \begin{align} \text{output}^{2}_{i} &amp;= \tanh \left( \sum_k \left( w^{2}_{k,i} \tanh(w^{1}_{k,i} x + w^{1}_{k,i} y + b^{1}_k) \right) + b^{2}_{i} \right)\\ &amp;= \tanh \left( w^{2}_{1,i} \tanh(w^{1}_{1,i} x + w^{1}_{1,i} y + b^{1}_1) + w^{2}_{2,i} \tanh(w^{1}_{2,i} x + w^{1}_{2,i} y + b^{1}_2) + ... + b^{2}_{i} \right) \end{align} $$ 重みとバイアスのパラメータが少し違うだけで、同じ層のニューロンなのにヒートマップの形状がここまで異なるのも面白いですね。
      br
      |  図を見ると2番目のニューロンのほうが出力層のニューロンにつながる線が太いことが分かります。 これは2番目のニューロンの線が出力に寄与する度合いが大きいことを示しています。
    p
      | さて、さきほど隠し層のニューロンの出力は特徴として見ることができると書きました。 そして良い特徴の選び方は出力をうまく説明する特徴だということも書きました。 ここでこの2番目のニューロンの形を見てみましょう。座標が原点に近いほど出力が大きいことが分かります。また、原点から離れるに従って 出力が小さくなる様子も見れます。 2次元平面上で原点に近いほど値が大きく、原点から離れるほど値が小さくなる特徴はどのように表現できるでしょうか。 私は下記のような特徴を考えました。 $$ \text{input} = -(x^2 + y^2) + 1 $$ です。$x = y = 0$で最大値$1$を取り、原点から離れるに従って値がマイナス方向に小さくなっていきます。 上のスクリーンショットでは$i_x = x$および$i_y = y$の2つの特徴を選択しました。 ですが、今回の隠し層のニューロンの出力を観察することで、より良い特徴は$i_{x^2}=x^2$と$i_{y^2}=y^2$であることが言えます。
    p
      | 試しにTensorFlow Playgroundで円のデータセットを選択し、$X^1$と$X^2$の2つの特徴を選択した状態で機械学習させた時の速さと、 $X^{12}$、$X^{22}$の2つの特徴を選択したときの速さを比べてみれば、その違いが体感できると思います。
    p  良い特徴を選ぶことの重要性が理解できる例です。
  .paragraph
    a#backpropagation-part.in-page-anchor
    h2(data-paragraph='') バックプロパゲーション(誤差逆伝搬法)
    hr
    .centering
      img.img-back-prop(src='image/learntensorflowplayground/backprop.png', alt='Back propagation', style='width:500px')
    p
      | 機械学習では誤差を最小にする重み$w_i$と$b$を探しますが、ここではその探し方について説明します。 バックプロパゲーションはその名の通り、最後の出力層から始まり最初の入力層に向けてトップダウンにパラメータ( $w_i,b$ )を修正します。 バックプロパゲーションに対してフォワードプロパゲーションという言葉もあります。 これは入力層から出力層まで層単位で順々にニューロンを通り最後に出力層に入力値が伝搬する 通常のボトムアップ型のニューラルネットワークの計算です。
      br
      |  バックプロパゲーションはその計算の順序が逆になります。出力層からスタートし入力層に至る向きで計算を進めます。
    p
      | 下記の式は現在の重み$w$から更新後の重み$w&apos;$を求めるための式です。 誤差の大きさ$C$を小さくする方向に$w$、$b$を修正していくアルゴリズムです。 このような形で機械学習のパラメータを探索する方法を勾配降下法と呼びます。 $$ \begin{align} w&apos; &amp;= w - \eta \frac{\partial C}{\partial w} \tag 1\\ b&apos; &amp;= b - \eta \frac{\partial C}{\partial w} \tag 2 \end{align} $$ さて、この式で最も知りたいのは下記の2つの項の値です。 $$ \frac{\partial C}{\partial w_i} $$ $$ \frac{\partial C}{\partial b} $$ コスト関数$C$はTensorFlow Playgroundでは $$C=C(\phi)=\frac{1}{2}\left(\phi - y\right)^2 $$ の形をしているため、 $$\frac{\partial C}{\partial w_i}$$を計算するためには偏微分の連鎖律を使い式を変形する必要があります。 上式を下記のように変形します。 $$ \frac{\partial C}{\partial w_i} = \frac{\partial C}{\partial \phi} \frac{\partial \phi}{\partial w_i} = \frac{\partial C}{\partial \phi} \frac{\partial \phi}{\partial z} \frac{\partial z}{\partial w_i} $$ $C$, $\phi$は選び方は様々ですが、上記の式を見れば分かる通り、偏導関数が計算しやすいかどうかも選び方のファクターになります。
      br
      |  TensorFlow Playgroundeの初期設定では$C$, $\phi$は下記の通りとなっています。(コスト関数$C$は2017/1/24現在設定変更はできません) $$ C = \frac{1}{2} \left( \phi - y \right)^2\\ \phi = tanh(z)\\ $$ $y$: 真の出力
      br
      |  $z$: 1つのニューロンの入力総和 $= \displaystyle \sum_{i} \left(w_i x_i\right) + b$
      br
      |  この時 $$ \begin{align} \frac{\partial C}{\partial \phi} &amp;= \phi - y \\ \frac{\partial \phi}{\partial z} &amp;= \frac{\partial tanh(z)}{\partial z} = 1 - tanh^2(z)\\ \frac{\partial z}{\partial w_i} &amp;= x_i \end{align} $$ となります。 ただし、この式の$$\frac{\partial C}{\partial \phi} $$の値は
      strong 出力層のニューロンのみで計算できるものであること
      | に注意してください。
      br
      |  コスト関数の定義$$C = \frac{1}{2} \left( \phi - y \right)^2$$を見れば分かる通り、この式中の$\phi$は出力層のニューロンの出力値を表したものであり、 隠し層のニューロンの出力、および重みの導出方法については別に考える必要があります。
    p
      | なお、出力層のニューロンのみ考えた場合、 $$ \frac{\partial C}{\partial w_i} = \frac{\partial C}{\partial \phi} \frac{\partial \phi}{\partial z} \frac{\partial z}{\partial w_i} = (\phi - y)\left(1-tanh^2(z)\right)x_i $$ となります。
      br
      |  この値を求めるためにはトレーニングデータの真の値 $y$ の他に前の層からの入力総和 $z$ 、重みづけの対象である前の層からの入力 $x_i$ 、 および$\phi(z)$の値がわかっていなければなりません。 そのためバックプロパゲーションを走らせるためにはその前に少なくとも一度はニューラルネットワークの初期パラメータを使って 出力層のニューロンまで計算を終え、ニューロンの出力が分かっている状態にしておく必要があります。
    p
      | 上記では出力層の重み・バイアスについてしか計算できませんでした。
      br
      |  次は、隠し層の重み$w_i$、$b$を計算する方法、ひいては $$ \frac{\partial C}{\partial w_i} \\ \frac{\partial C}{\partial b} $$ の出力層に限定されない、より一般化した式の展開形について説明します。
    .centering
      img#img-backprop.img-back-prop(src='image/learntensorflowplayground/backprop.png', alt='Back propagation')
    p
      | まずは上図のそれぞれの変数について確認します。ちなみに、上の図をクリックすると図が画面右上にポップアップします。 これ以降数式が文章中に度々表れますが、図を見ながらでないと何が書いてあるのか理解するのが難しいため、図を常に表示させた状態で 読み進めることを強く勧めます。
    p
      | 図の上部の$l-1, l, l+1, L$はそれぞれ層の番号です。$l-1$ 番目の隠し層、$l$、$l+1$ 番目の隠し層といった形で見てください。
      br
      |  $L$ 番目の層は出力層とします。
      br
      |  $b^{l}_{q}$ は層 $l$ の $q$ 番目のニューロンのバイアスです。
      br
      |  $w^{l}_{q,p}$ は層 $l$ の $q$ 番目のニューロンが層 $l-1$ の $p$番目のニューロンからの入力にかける重みです。
      br
      |  $a^{l}_{q}$ は層 $l$ の $q$ 番目のニューロンの出力です。活性化関数を$\phi$とすると
      br
      |  $$ a^{l}_{q} = \phi(z^{l}_{q})$$ となります。 $z^{l}_{q}$ は層 $l$ の $q$ 番目のニューロンが受け取る入力の総和です。ニューロンの入力は、前の層のニューロンの出力$a$を用いて $$ z^{l}_{q} = \sum_{k} \left( w^{l}_{q,k} \cdot a^{l-1}_{k} \right) + b^{l}_{q} $$ と表現できます。
      br
    p
      | さて、残りはひとつ、$\delta^{l}_{q}$です。
      br
      |  この変数が隠し層における重み$w_i$、バイアス$b$を計算するための鍵となる変数です。 $\delta^{l}_{q}$ を層 $l$ の$q$ 番目のニューロンのエラーと呼びます。 $$\delta^{l}_{q} := \frac{\partial C}{\partial z^{l}_{q}}$$ と定義します。意味としては、層$l$のニューロン$q$の入力総和$z^{l}_{q}$を微小量$\Delta z^{l}_{q}$だけ増やした時に増える誤差$\Delta C$の量です。
      br
      |  非常に興味深いのは最終出力と真の値の誤差関数である$C$の、最終的な出力層ではない中間の層の値の変動が$C$に与える影響についての式だということです。 当然ながら、$C$を$z^{l}_{q}$の関数で表現することは容易ではありません。しかし $$\delta^{l}_{q} = \frac{\partial C}{\partial z^{l}_{q}}$$ は非常に重要な式です。
    p
      | なぜならば私達が最も知りたい$\dfrac{\partial C}{\partial w^{l}_{q,p}}$、$\dfrac{\partial C}{\partial b^{l}_{q}}$は、 ニューロンのエラー$\delta^{l}_{q}$を使って下記のように表せるからです。 $$ \begin{align} \frac{\partial C}{\partial w^{l}_{q,p}} &amp;= a^{l-1}_{p} \delta^{l}_{q} \tag{3}\\ \frac{\partial C}{\partial b^{l}_{q}} &amp;= \delta^{l}_{q} \tag{4} \end{align} $$ つまりニューロンのエラー$\delta^{l}_{q}$の値が分かれば、任意のニューロンの次のステップの重み$w^{l}_{q,p}$、バイアス$b^{l}_{q}$が求まるということです。
    p
      | この章の残りは、上の(3),(4)の証明と、$\delta^{l}_{q}$の求め方になります。
      br
      |  説明の都合上、最初に$\delta^{l}_{q}$の求め方を説明したあと最後に(3),(4)を証明する順番で解説します。
    h4
      i.material-icons.md-24(style='color: white;') lens
      |  $\delta$の求め方
    p
      | $$\delta^{l}_{q} = \frac{\partial C}{\partial z^{l}_{q}}$$ のままではいくら式を眺めていてもどうすれば良いのか検討もつかないと思います。 そこで右辺を合成関数の偏微分の連鎖律を使い、下記のように変形します。 $$ \frac{\partial C}{\partial z^{l}_{q}} = \sum_{k} \frac{\partial C}{\partial z^{l+1}_{k}} \frac{\partial z^{l+1}_{k}}{\partial z^{l}_{q}} $$ $z^{l+1}_{k}$は層$l+1$の$k$番目のニューロンです。 この式は、層$l$のq番目の1つのニューロンの入力総和$z^{l}_{q}$の微小変化が最終誤差$C$に与える影響は 次の層$l+1$の全ニューロンの入力総和$z^{l+1}_{k}$の微小変化を用いて表現できることを示しています。
      br
    details#chain-rule
      summary 補足: 合成関数の偏微分の連鎖律
      p
        | $x = x(t)$、$y = y(t)$が$t$で微分可能であり、$x$,$y$に関する2変数関数$f(x,y)$について$(x(t),y(t))$で微分可能であれば $$ \frac{\partial f}{\partial t} = \frac{\partial f}{\partial x} \frac{\partial x}{\partial t} + \frac{\partial f}{\partial y} \frac{\partial y}{\partial t} $$ これを$n$変数関数に拡張すると、
        br
        |  $x_1(t),\,x_2(t),\,...,\,x_n(t)$が$t$で微分可能であり、$x_1,\,...\,,x_n$に関する$n$変数関数$f(x_1,\,...,\,x_n)$について$(x_1(t),\,...,\,x_n(t))$で微分可能であれば
        br
        |  $$ \frac{\partial f}{\partial t} = \frac{\partial f}{\partial x_1} \frac{\partial x_1}{\partial t} + \frac{\partial f}{\partial x_2} \frac{\partial x_2}{\partial t} + ... + \frac{\partial f}{\partial x_n} \frac{\partial x_n}{\partial t} = \sum_{i}^{n} \frac{\partial f}{\partial x_i} \frac{\partial x_i}{\partial t} $$
    p
      | 次に、 $$ \delta^{l+1}_{k} = \frac{\partial C}{\partial z^{l+1}_{k}} $$ であるので $$ \sum_{k} \frac{\partial C}{\partial z^{l+1}_{k}} \frac{\partial z^{l+1}_{k}}{\partial z^{l}_{q}} = \sum_{k} \delta^{l+1}_{k} \frac{\partial z^{l+1}_{k}}{\partial z^{l}_{q}} $$ と書き換えることができます。
      br
      |  次に上式の右辺の $$ \frac{\partial z^{l+1}_{k}}{\partial z^{l}_{q}} $$ について考えます。入力総和$z$は重み$w$と前の層の出力$a$およびバイアス$b$を使って以下のように書けます。 $$ z^{l+1}_{k} = \sum_{j} \left( w^{l+1}_{k,j} a^{l}_{j} \right) + b^{l+1}_{k} = \sum_{j} \left( w^{l+1}_{k,j} \phi (z^{l}_{j}) \right) + b^{l+1}_{k} $$ 上記の $z^{l+1}_{k}$ を$z^{l}_{q}$で偏微分すると $$ \frac{\partial z^{l+1}_{k}}{\partial z^{l}_{q}} = \sum_{j} \left( w^{l+1}_{k,j} \frac{\partial \phi(z^{l}_{j})}{\partial z^{l}_{q}} \right) = w^{l+1}_{k,q} \frac{\partial \phi(z^{l}_{q})}{\partial z^{l}_{q}} = w^{l+1}_{k,q} \phi&apos;(z^{l}_{q}) $$ と変形できます。ただし、$\phi&apos;$は活性化関数$\phi$の入力総和$z$についての導関数です。
      br
      |  上式において、 $$ \frac{\partial \phi(z^{l}_{j})}{\partial z^{l}_{q}} = 0;\quad j \ne q $$ であることに注意してください。
      br
      |  図を見れば層$l$のニューロン$q$の入力総和$z^{l}_{q}$を変えたところで、 同じ層$l$の他のニューロンの出力 $\phi(z^{l}_{j})$ には影響が無いことはすぐに分かります。
      br
      |  よって $$ \delta^{l}_{q} = \sum_{r} \delta^{l+1}_{r} w^{l+1}_{r,q} \phi&apos;(z^{l}_{q}) \tag 5 $$ となります。 この式は層$l+1$の全ニューロンのエラーと重みが分かっていれば、一つ前の層$l$のニューロンのエラーが求まることを示しています。
      br
      |  つまり、$l = L$の出力層のエラー$\delta^{L}$が分かれば、帰納的に出力層から入力層の向きに順々にニューロンのエラー$\delta^{l}$も求まるということです。
      br
      |  式$(5)$はバックプロパゲーションの名前の由来を物語っています。
    p
      | それでは出力層$L$のニューロンのエラーを求めてみましょう。これが分かれば帰納的に入力層までの全ニューロンについてエラーが計算できるようになります。
      br
      |  元々の定義より、 $$ \delta^{L}_{s} = \frac{\partial C}{\partial z^{L}_{s}} $$ です。ここで$s$は出力層$L$の$s$番目のニューロンです。
      br
      |  偏微分の連鎖律を使ってこの式を変形します。 $$ \frac{\partial C}{\partial z^{L}_{s}} = \frac{\partial C}{\partial a^{L}_{s}} \frac{\partial a^{L}_{s}}{\partial z^{L}_{s}} $$ ここで、誤差関数$C$および活性化関数$a = \phi(z)$は事前にその形を $$ C = \frac{1}{2} \left( a - y \right)^2 $$ $$ a = \phi(z) = tanh(z) $$ と決めているので、 $$ \delta^{L}_{s} = \frac{\partial C}{\partial z^{L}_{s}} = (a^{L}_{s}-y)\left( 1 - tanh^2(z^{L}_{s}) \right) $$ と簡単に求まります。
    h4
      i.material-icons.md-24(style='color: white;') lens
      |  $\frac{\partial C}{\partial w^{l}_{q,p}}=a^{l-1}_{p}\delta^{l}_{q}$ と $\frac{\partial C}{\partial b^{l}_{q}}=\delta^{l}_{q}$ の証明
    p
      | ここまでで任意のニューロンのエラー$\delta^{l}_{q}$が求まるようになりました。
      br
      |  次はニューロンのエラー$\delta$で$\dfrac{\partial C}{\partial w^{l}_{q,p}}$と$\dfrac{\partial C}{\partial b^{l}_{q}}$ が計算できることを示します。
    p  まずは$\dfrac{\partial C}{\partial b^{l}_{q}}=\delta^{l}_{q}$を証明します。
    p
      | 合成関数の連鎖律を使い、 $$ \frac{\partial C}{\partial b^{l}_{q}} = \sum_r \frac{\partial C}{\partial z^{l+1}_{r}} \frac{\partial z^{l+1}_{r}}{\partial b^{l}_{q}} $$ と変形します。層$l+1$のニューロン$r$の入力総和$z^{l+1}_{r}$は層$l$のニューロンが加えたバイアス$b$の影響を受けていることは図を見れば明らかです。 ここで、 $$ \frac{\partial C}{\partial z^{l+1}_{r}} = \delta^{l+1}_{r} $$ です。また、 $$ z^{l+1}_{r} = \sum_q w^{l+1}_{r,q} a^{l}_{q} + b^{l+1}_{r} $$ であるので $$ \frac{\partial z^{l+1}_{r}}{\partial b^{l}_{q}} = w^{l+1}_{r,q} \frac{\partial a^{l}_{q}}{\partial b^{l}_{q}} = w^{l+1}_{r,q} \frac{\partial a^{l}_{q}}{\partial z^{l}_{q}} \frac{\partial z^{l}_{q}}{\partial b^{l}_{q}} = w^{l+1}_{r,q} \frac{\partial a^{l}_{q}}{\partial z^{l}_{q}} $$ と変形できます。よって $$ \frac{\partial C}{\partial b^{l}_{q}} = \sum_r \frac{\partial C}{\partial z^{l+1}_{r}} \frac{\partial z^{l+1}_{r}}{\partial b^{l}_{q}} = \sum_r \delta^{l+1}_{r} w^{l+1}_{r,q} \frac{\partial a^{l}_{q}}{\partial z^{l}_{q}} $$ となります。式$(5)$から $$ \delta^{l}_{q} = \sum_{r} \delta^{l+1}_{r} w^{l+1}_{r,q} \phi&apos;(z^{l}_{q}) \tag 5 $$ であるので $$ \therefore \frac{\partial C}{\partial b^{l}_{q}} = \delta^{l}_{q} $$ が導かれました。
    p
      | 同様に $$ \frac{\partial C}{\partial w^{l}_{q,p}} = a^{l-1}_{p} \delta^{l}_{q} $$ を求めます。 $$ \frac{\partial C}{\partial w^{l}_{q,p}} = \sum_r \frac{\partial C}{\partial z^{l+1}_{r}} \frac{\partial z^{l+1}_{r}}{\partial w^{l}_{q,p}} = \sum_r \frac{\partial C}{\partial z^{l+1}_{r}} \frac{\partial z^{l+1}_{r}}{\partial a^{l}_{q}} \frac{\partial a^{l}_{q}}{\partial w^{l}_{q,p}} $$ ここで $$ z^{l+1}_{r} = \sum_q w^{l+1}_{r,q} a^{l}_{q} + b^{l+1}_{r} $$ であるので $$ \frac{\partial z^{l+1}_{r}}{\partial a^{l}_{q}} = w^{l+1}_{r,q} $$ です。また $$ \frac{\partial a^{l}_{q}}{\partial w^{l}_{q,p}} = \frac{\partial a^{l}_{q}}{\partial w^{l}_{q,p}} = \frac{\partial a^{l}_{q}}{\partial z^{l}_{q}} \frac{\partial z^{l}_{q}}{\partial w^{l}_{q,p}} = \frac{\partial a^{l}_{q}}{\partial z^{l}_{q}} a^{l-1}_{p} $$ であるので $$ \therefore \frac{\partial C}{\partial w^{l}_{q,p}} = \sum_r \frac{\partial C}{\partial z^{l+1}_{r}} \frac{\partial z^{l+1}_{r}}{\partial a^{l}_{q}} \frac{\partial a^{l}_{q}}{\partial w^{l}_{q,p}} = \sum_r \frac{\partial C}{\partial z^{l+1}_{r}} w^{l+1}_{r,q} \frac{\partial a^{l}_{q}}{\partial z^{l}_{q}} a^{l-1}_{p} = \delta^{l}_{q} a^{l-1}_{p} $$ となります。
    p
      | ここまで導出した式を下記にまとめます。 $$ \delta^{l}_{q} = \sum_{r} \delta^{l+1}_{r} w^{l+1}_{r,q} \phi&apos;(z^{l}_{q}) $$ $$ \delta^{L}_{s} = \frac{\partial C}{\partial z^{L}_{s}} = (a^{L}_{s}-y)\left( 1 - tanh^2(z^{L}_{s}) \right) $$ $$ \frac{\partial C}{\partial w^{l}_{q,p}} = \delta^{l}_{q} a^{l-1}_{p} $$ $$ \frac{\partial C}{\partial b^{l}_{q}} = \delta^{l}_{q} $$ バックプロパゲーションではこれらの式より1ステップ後の重み$w&apos;$とバイアス$b&apos;$を計算します。

script(type='text/javascript', async='', src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML')
script(type='text/x-mathjax-config').
  MathJax.Hub.Config({
  tex2jax: {
  inlineMath: [['$','$']],
  processEscapes: true
  },
  CommonHTML: {matchFontHeight: false },
  displayAlign: "left",
  displayIndent: "2em"
  });
